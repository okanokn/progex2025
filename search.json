[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "プログラミング演習",
    "section": "",
    "text": "目次\n2025年度プログラミング演習 Bクラスの授業資料です．\n\n第1週，+R授業\n第2週\n第3週\n第4週\n第5週\n第6週\n第7週\n第8週\n第9週\n第10週\n第11週\n第12週\n第13週\n第14週\n\n本資料を作成するに当たり，毛利先生（Aクラス担当）の授業資料，松井勇佑先生の授業資料を参考にさせていただきました．",
    "crumbs": [
      "目次"
    ]
  },
  {
    "objectID": "week01.html",
    "href": "week01.html",
    "title": "1  ガイダンス・環境構築",
    "section": "",
    "text": "1.1 +R授業のコンテンツ\n+R授業では，C言語プログラムの開発環境について，オンライン・オフラインそれぞれの環境設定方法を説明する．オンライン環境については，Google Cloud Shell Editorの使い方を本稿で述べる．オフライン環境については，毛利先生による解説動画を別途アップロードする．\n本講義（プログラミング演習Bクラス）では，オンラインの開発環境としてGoogle Cloud Shell Editorを推奨する．Googleアカウントが必要となるので，アカウントを取得できない場合や，本講義でアカウントを使用したくない場合は，オフライン環境を使用すること．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#google-cloud-shell-editorについて",
    "href": "week01.html#google-cloud-shell-editorについて",
    "title": "1  ガイダンス・環境構築",
    "section": "1.2 Google Cloud Shell Editorについて",
    "text": "1.2 Google Cloud Shell Editorについて\nインターネットを経由してGoogle社が管理するサーバに接続すると，サーバ内で仮想マシンが起動する．Googleアカウントがあれば無料で使用できるが，いくつか使用上の制限がある:\n\n1週間の使用時間が50時間以下に制限される\n20分間キー入力がないと接続が切断され，再接続が必要となる（作成したファイルは残る）\n120日間アクセスがない場合はホームフォルダの中身が自動的に削除される\nストレージサイズは5 GB\n\n\n\n\n\n\n\nTip\n\n\n\n仮想マシンのOSは，DebianベースのLinux OSとのこと1．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#エディタを起動する",
    "href": "week01.html#エディタを起動する",
    "title": "1  ガイダンス・環境構築",
    "section": "1.3 エディタを起動する",
    "text": "1.3 エディタを起動する\nまずはエディタを起動してみよう：\n\nGoogle Cloud Shell Editor (https://ide.cloud.google.com/) にアクセスする\nGoogleアカウントにログインしていない場合は，ダイアログに従ってログインする\nしばらく待つと仮想マシンが起動する\n\n起動直後は下図のような画面である．右端にGeminiの広告パネルが表示されている場合は，✕ボタンで閉じてよい．\n\n左上の File メニューからOpen Folderを選択して，ホームフォルダを開いてみよう．Open Folderという青いボタンからでもよい．ホームフォルダは，/home/自分のGoogleアカウント名である．\n左側のペインに開いているフォルダ内のファイルが一覧で表示される．初期状態ではREADME-cloudshell.txtが存在しているはず\n\n右上のペンマークのとなりのボタンを押すと，ターミナルウィンドウが表示される．\n\nターミナルとは，テキストコマンドでコンピュータの操作を行うためのアプリケーションである．（仮想）端末とも呼ばれる．Windowsでは古くはコマンドプロンプト，最近ではWindows Terminalがある．\nプログラムのコンパイル，コンパイルしたプログラムの実行などをターミナルにコマンドを入力することで行う．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#ターミナルを使ってみる",
    "href": "week01.html#ターミナルを使ってみる",
    "title": "1  ガイダンス・環境構築",
    "section": "1.4 ターミナルを使ってみる",
    "text": "1.4 ターミナルを使ってみる\nターミナルにコマンドを打ち込んでコンピュータを操作する練習をしてみよう．\n現在の作業フォルダを表示するコマンドpwdを$マークの右側に打ち込み，EnterEnterキーで実行する．\nkunihisa_okano@cloudshell:~$ pwd\n/home/kunihisa_okano\n1行目の$の右側が入力したコマンド，2行目は実行結果を示している．kunihisa_okanoは筆者のGoogleアカウント名である． なお，$の左側は，ログイン名@マシン名:カレントフォルダ$を表す． 以後のコマンド例では$の右側のみを記述する．\nファイルの中身をテキストで表示するcatコマンドを使ってみよう．\ncat README-cloudshell.txt # 実行するとファイルの中身がターミナルに表示される\nここで，表示したいファイル名README-cloudshell.txtをすべて手動で入力する必要はない．RRのあとにTabTabキーを押せば，作業フォルダ内でRから始まるファイル名を自動的に補完してくれる．\n現在のフォルダに，テスト用のフォルダtest_dirを作成しよう．mkdirコマンド2で作成して，lsコマンドで作成結果を確認する：\nmkdir test_dir # test_dir という名前のフォルダを作成\nls # ファイル一覧が表示される．新たに test_dir が追加されている\n#以降はコメントなので入力する必要はない．\n作成したディレクトリtest_dirに作業ディレクトリを移動しよう．cdコマンドを使う．\ncd test_dir # test_dirへ移動\npwd # 移動できたか確認する\nフォルダ階層を相対パスで表すには，., ..を使う．\n\n. 現在のフォルダ\n.. 一つ上の階層\n~ ホームフォルダ\n\nたとえば，一つ上のフォルダに移動したい場合はつぎのようにする．\ncd .. # ひとつ上のフォルダに移動\ncd test_dir # 戻る\nこのほか，以下のコマンドはよく使う．\n\nmv ファイルを移動，名前の変更\ncp ファイルをコピー\nrm ファイルを削除",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#c言語ソースファイルの作成とコンパイル",
    "href": "week01.html#c言語ソースファイルの作成とコンパイル",
    "title": "1  ガイダンス・環境構築",
    "section": "1.5 C言語ソースファイルの作成とコンパイル",
    "text": "1.5 C言語ソースファイルの作成とコンパイル\ntest_dirにhello.cというC言語のソースファイルを作成してみよう．\ntouch hello.c # 作業フォルダに hello.c という名前の新規ファイルを作成\nファイル一覧領域でhello.cを選択すると，エディタ領域でこのファイルを編集できる．\n\nhello.cを編集して，標準出力にHellow worldというテキストを出力するプログラムを作成しよう．\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"Hello world\\n\");\n    return 0;\n}\n作成したファイルをコンパイルするには，ターミナルでgccを呼び出す．\ngcc hello.c\nプログラム中にタイプミスなどがあると，コンパイラが警告やエラーを出力する．メッセージを読んで該当箇所を修正しよう．\nコンパイルによって作成した実行ファイルは，自動的にa.outという名前がつけられる． これを実行してみよう．\n./a.out # Hello world と表示される\n行頭の./は，a.outという実行ファイルが現在のフォルダに存在することを示す．a.outはコマンドとしてコンピュータが認識していないので，どこのa.outなのか，実行するファイルの所在地を明示的に記述する必要がある．\n\n\n\n\n\n\nTip\n\n\n\n実行ファイル名をa.out以外にするには，gcc hello.c -o helloのようにoオプションの後に実行ファイル名を記述する．実行するときは，./helloとする．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#作成したファイルをローカルpcに保存する",
    "href": "week01.html#作成したファイルをローカルpcに保存する",
    "title": "1  ガイダンス・環境構築",
    "section": "1.6 作成したファイルをローカルPCに保存する",
    "text": "1.6 作成したファイルをローカルPCに保存する\n作成したソースコードをローカルPCに保存するには，保存したいファイルを選択した状態でFileメニュー &gt; Save As を選択して，\n\n表示されるダイアログで，Show Localを選択する．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#オフライン環境の構築方法",
    "href": "week01.html#オフライン環境の構築方法",
    "title": "1  ガイダンス・環境構築",
    "section": "1.7 オフライン環境の構築方法",
    "text": "1.7 オフライン環境の構築方法\nWindowsユーザーの場合は，別途アップロードする毛利先生による解説動画を参照する．\nmacOSユーザーの場合は，App StoreからXcodeをインストールする． Xcodeは容量が大きいので，ストレージ容量が気になる場合は，Command Line Toolsをインストールする．\nxcode-select --install\nエディタは好きなものを使えばよいが，Visual Studio Code を推奨する．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#footnotes",
    "href": "week01.html#footnotes",
    "title": "1  ガイダンス・環境構築",
    "section": "",
    "text": "https://cloud.google.com/shell/docs/how-cloud-shell-works↩︎\nMake directoryの略．↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week02.html",
    "href": "week02.html",
    "title": "2  C言語の復習 1",
    "section": "",
    "text": "2.1 本日のメニュー",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#本日のメニュー",
    "href": "week02.html#本日のメニュー",
    "title": "2  C言語の復習 1",
    "section": "",
    "text": "演算子\n型\n分岐 (if)\n繰り返し (for)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#準備",
    "href": "week02.html#準備",
    "title": "2  C言語の復習 1",
    "section": "2.2 準備",
    "text": "2.2 準備\nGoogle Cloud Shell Editor (https://ide.cloud.google.com/)を立ち上げて，ホームフォルダ(/usr/自分のgoogleアカウント名)を開く． ホームフォルダに今日の演習ファイルを格納するフォルダ02を作成して，ターミナルの作業フォルダを/usr/自分のgoogleアカウント名/02に移動させる．\n\n\n\nコマンド\n用途\n用例\n\n\n\n\npwd\n現在の作業フォルダを表示\npwd\n\n\nmkdir\nフォルダを生成\nmkdir 02\n\n\ncd\n作業フォルダを移動\ncd 02\n\n\ntouch\n新規ファイル生成\ntouch hoge.c",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#四則演算",
    "href": "week02.html#四則演算",
    "title": "2  C言語の復習 1",
    "section": "2.3 四則演算",
    "text": "2.3 四則演算\n整数を2つ読み込み，それらの足し算，引き算，掛け算，割り算の計算結果と，割り算の余りを表示するプログラムcalc2int.cを作成しよう．\n数値を入力するメッセージの表示はprintf関数で，入力された数値の読み込みはscanf関数で行う．\nint a;\nprintf(\"1番目の整数を入力してください: \");\nscanf(\"%d\", &a);\n四則演算を行う演算子を復習しよう．\nprintf(\"a + b = %d\\n\", a + b); // a+b\nprintf(\"a - b = %d\\n\", a - b); // a-b\nprintf(\"a * b = %d\\n\", a * b); // a*b\nprintf(\"a / b = %d\\n\", a / b); // a/bの商を表示 !注意!\nprintf(\"a %% b = %d\\n\", a % b); // bをaで割った余りを表示\nたとえばa = 2, b = 3のように代入した場合，a/bの計算結果は電卓で2/3を計算した結果と異なり，0が出力される． これは，a, bがともに整数を表すint型であることと，printfの出力形式%dが整数値書式となっているため．\nprintf中で，パーセント記号は出力書式を表す特殊文字として使われるので，%と書くだけではパーセント記号を出力しない． パーセント記号自身を文字として表示したい場合は，%%のように2回続けて記述する1．\n計算に用いる値に小数が含まれている場合は，自動的に小数で計算される．\nprintf(\" 2 / 3 = %d\\n\", 2/3);         // 小数点以下を切り捨てた 0\nprintf(\" 2.0 / 3 = %d\\n\", 2.0/3);     // 小数で計算されるが出力書式がint指定なので変な値に\nprintf(\" 2.0 / 3 = %f\\n\", 2.0/3);     // 0.666667 (内部的には更に下の桁まで計算されている)\nprintf(\" 2.0 / 3.0 = %f\\n\", 2.0/3.0); // 0.666667 (内部的には更に下の桁まで計算されている)\n\n\n\n\n\n\n負の数を用いた除算\n\n\n\n少なくとも1つが負の数の場合，/の計算結果が「商以下の最大の整数」となるか「商以上の最小の整数」となるかは，処理系に依存する．",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#型",
    "href": "week02.html#型",
    "title": "2  C言語の復習 1",
    "section": "2.4 型",
    "text": "2.4 型\n基本的には，整数はint，小数にはdoubleを使う．\n\n\n\n\n\n\n\n\n\n\n型\n用途\nバイト数\n範囲(処理系依存)\n書式指定子\n\n\n\n\nchar\n文字\n1\n\\(-127\\)–\\(128\\)\n%c,%s\n\n\nint\n整数\n4\n\\(-32768\\)–\\(32767\\)\n%d\n\n\nlong\n整数\n4\n\\(-2147483648\\)–\\(2147483647\\)\n%ld\n\n\nunsigned char\n文字\n2\n\\(0\\)–\\(255\\)\n%c,%s\n\n\nunsigned int\n符号なし整数\n4\n\\(0\\)–\\(65535\\)\n%u\n\n\nunsigned short\n符号なし整数\n2\n\\(0\\)–\\(65535\\)\n%hu\n\n\nunsigned long\n符号なし整数\n4\n\\(0\\)–\\(4294967295\\)\n%lu\n\n\nfloat\n単精度浮動小数点数\n4\n有効桁数6–7\n%f\n\n\ndouble\n倍精度浮動小数点数\n8\n有効桁数15–16\n%lf\n\n\n\n\n\n\n\n\n\n\nintとdoubleの演算ではintで宣言された変数の値が自動的にdoubleに変換されて計算が行われる． どのような場合に暗黙の型変換が行われるかを網羅的に書くことは難しいが，とりあえずはintとdoubleの関係について知っておけばよい．\n明示的に型変換を行いたい場合は，(型名)(変換対象の式)のように書く． これをキャストという．\nint a = 1;\nint b = 2;\ndouble c = (double)(a + b) / 2 // intのa+bをdoubleに変換してから 2 で除す→計算結果はdouble",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#分岐-if",
    "href": "week02.html#分岐-if",
    "title": "2  C言語の復習 1",
    "section": "2.5 分岐 if",
    "text": "2.5 分岐 if\nプログラムの処理を，条件によって分岐させるにはif文を使う． 次のプログラムは，入力された整数が偶数の場合，そのように出力するプログラム（の一部）である． evenorodd.cというファイルを作成し，以下の内容を書き写して実行してみよう．\nint a;\nprintf(\"整数を入力してください: \");\nscanf(\"%d, &a\");\nif(a % 2 == 0){\n  printf(\"aは偶数です\\n\");\n}\nif(式)で式の真偽によってプログラムの実行が分岐する．式が真の場合のみifの直後のブロックが実行される．ブロックとは，{}で囲われた部分のことである．\nさらに，式が偽の場合の動作を別途指定したい場合は，elseを使う．\nint a;\nprintf(\"整数を入力してください: \");\nscanf(\"%d, &a\");\nif(a % 2 == 0){\n  printf(\"aは偶数です\\n\");\n}else{\n  printf(\"aは奇数です\\n\");\n}\n最初の式が偽の場合に，さらに別の条件で分岐を行う場合はelse ifを使う．\nint a;\nprintf(\"整数を入力してください: \");\nscanf(\"%d, &a\");\nif(a &lt; 0){\n  printf(\"aは負の数です\\n\");\n}else if (a % 2 == 0){\n  printf(\"aは正の偶数です\\n\");\n}else{\n  printf(\"aは正の奇数です\\n\");\n}\nまた，if文のなかにif文を書くこともできる． 次のプログラムは，上のプログラムと同一だが，elseの中に別のif文が入っている．\nint a;\nprintf(\"整数を入力してください: \");\nscanf(\"%d, &a\");\nif(a &lt; 0){\n  printf(\"aは負の数です\\n\");\n}else{\n  if (a % 2 == 0){\n    printf(\"aは正の偶数です\\n\");\n  }else{\n    printf(\"aは正の奇数です\\n\");\n  }\n}\nこのように，ブロックの中に別のブロックが入る場合は，インデント（行頭の空白文字の長さ）をブロックの深さごとに変えて，視覚的にプログラムの構造を表すとよい． 多くのエディタではインデントを自動的に整形する機能がついている． Google Cloud Shell EditorではFormat Documentコマンドで整形できる． これを呼び出すには，でメニューを呼び出し，Format Documentと入力するか，のショートカットキーを使う．\n条件に大小関係を用いる場合は，関係演算子を用いて記述する．\n\n\n\n演算子\n用例\n意味\n\n\n\n\n&lt;\na &lt; b\naがb未満ならば真，そうでなければ偽\n\n\n&gt;\na &gt; b\naがbより大きければ真，そうでなければ偽\n\n\n&lt;=\na &lt;= b\naがb以下ならば真，そうでなければ偽 (=&lt;は不可)\n\n\n&gt;=\na &gt;= b\naがb以上ならば真，そうでなければ偽 (=&gt;は不可)\n\n\n==\na == b\naとbが等しければ真，そうでなければ偽\n\n\n!=\na != b\naとbが異なれば真，そうでなければ偽\n\n\n\n式で複数の条件を複合したい場合は，\n\n&& AND, 論理積\n|| OR, 論理和\n! NOT, 否定\n\nを組合わせて表現します．\n\n\n\n\n\n\n真偽を表す数値\n\n\n\nC言語では，整数0が偽を表し，それ以外は真を表す． 真を表す数値を明示的に書く場合には1がよく用いられるが，1以外も0でなければ真であることに注意．",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#分岐-switch",
    "href": "week02.html#分岐-switch",
    "title": "2  C言語の復習 1",
    "section": "2.6 分岐 switch",
    "text": "2.6 分岐 switch\n3つ以上の処理に分岐したい場合はswitch文を使うことができる． 以下は，入力された整数の剰余を計算して，その値によってテキストを出力するプログラムである． mod3.cというファイルを作成し，以下の内容を書き写して実行してみよう．\nint a;\nprintf(\"整数を入力してください: \");\nscanf(\"%d\", &a);\n\nswitch(a % 3){\n  case 0 :\n    printf(\"3で割り切れます\\n\");\n    break;\n  case 1 :\n    printf(\"3で割った余りは1です\\n\");\n    break;\n  case 2 :\n    printf(\"3で割った余りは2です\\n\");\n    break;\n  default :\n    printf(\"剰余が0, 1, 2のいずれでもありません\\n\");\n}\nswitch文は次のような構造になっている．\nswitch(式){\n  case 定数式: 文\n  case 定数式: 文\n  default: 文\n}\n式の値が，caseのあとに続く定数式に合致する箇所にジャンプし，それ以後の文を実行する． defaultは，どのcaseにも合致しない場合に実行される． breakは，その行でswitch文のブロックを抜ける動作をする． つまり，switch文直後のブロックの後に処理が移動する． もしbreakが無いと，その後のcaseの文も実行される． （個人的には，switchを使わずにifで書いたほうがわかりやすいと思う．）",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#繰り返し-for",
    "href": "week02.html#繰り返し-for",
    "title": "2  C言語の復習 1",
    "section": "2.7 繰り返し for",
    "text": "2.7 繰り返し for\n繰り返し特定の処理を行いたい場合はfor文を使う． 以下のプログラムは，“hello world”を10回繰り返して出力する． “world”の後には繰り返し回数を表示する． hello10.cというファイルを作成し，以下の内容を書き写して実行してみよう．\nint i;\nfor(i=0; i &lt; 10; i = i + 1){\n  printf(\"hello world %d\\n\", i+1);\n}\nfor文は以下のような構造をもつ:\nfor(式1; 式2; 式3)\nまず式1を実行し，つぎに式2を評価する． 評価結果が真であればfor文の直後のブロックを実行する． その後，式3を実行して式2の真偽評価に戻る． これを，式2の評価が偽となるまで繰り返す．\n\n\n\n\n\n\n無限ループを止める\n\n\n\n無限ループを含むプログラムを実行して入力を受け付けなくなってしまった場合は，ターミナル上でControl-CControl-Cを押すと止まる．",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#演習",
    "href": "week02.html#演習",
    "title": "2  C言語の復習 1",
    "section": "2.8 演習",
    "text": "2.8 演習\n以下の問題に取り組み，ソースコードをmanaba+Rにアップロードせよ．",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#問題1",
    "href": "week02.html#問題1",
    "title": "2  C言語の復習 1",
    "section": "2.9 問題1",
    "text": "2.9 問題1\n3つの整数値を読み込み，それらの平均を表示するプログラムave3int.cを作成せよ",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#問題2",
    "href": "week02.html#問題2",
    "title": "2  C言語の復習 1",
    "section": "2.10 問題2",
    "text": "2.10 問題2\n1つの整数値を読み込み，最も下の桁の数を表示するプログラムleastdigit.cを作成せよ",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#問題3",
    "href": "week02.html#問題3",
    "title": "2  C言語の復習 1",
    "section": "2.11 問題3",
    "text": "2.11 問題3\n整数値を読み込み，その回数だけおみくじの結果を表示するプログラムomikuji.cを作成せよ．ただし，おみくじは「大吉」，「吉」，「小吉」，「凶」，「大凶」のいずれかを等確率で選択するとする\n\nstdlib.hを読み込んでrand()を使うと整数の乱数を作成できる\n乱数の範囲は0からRAND_MAXで指定されている",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#footnotes",
    "href": "week02.html#footnotes",
    "title": "2  C言語の復習 1",
    "section": "",
    "text": "このエスケープ方法はprintf関数に直接%%を書く場合のみ有効．たとえばputs(\"%%\");や，char a[5]; strcpy(a, \"%%\"); printf(\"%s\", a);は%%を出力する．↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week03.html",
    "href": "week03.html",
    "title": "3  C言語の復習 2",
    "section": "",
    "text": "3.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#前回演習の解答",
    "href": "week03.html#前回演習の解答",
    "title": "3  C言語の復習 2",
    "section": "",
    "text": "intのみの演算で小数となる場合はdoubleにキャストする\nブロック構造を可視化するためにインデントを揃える\n複数の条件の論理演算\n\n0 &lt;= a &lt;= 1は不可．0 &lt;= a && a &lt;= 1\nif文条件式の順番\n\n\n\n\n\n\n\n\nTip\n\n\n\nprintfと入力すると，format:という文言が自動補完機能で追加される．邪魔なので補完機能をオフに設定するとよい1: 画面左下の歯車アイコン &gt; Settings &gt; 検索ボックスにinlayと入力 &gt; Inlay Hints: Enabledをoffに設定 &gt; Settingsタブを閉じる",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#今日のメニュー",
    "href": "week03.html#今日のメニュー",
    "title": "3  C言語の復習 2",
    "section": "3.2 今日のメニュー",
    "text": "3.2 今日のメニュー\n\n繰り返し while, do while\n配列",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#繰り返し-while",
    "href": "week03.html#繰り返し-while",
    "title": "3  C言語の復習 2",
    "section": "3.3 繰り返し while",
    "text": "3.3 繰り返し while\nwhile文の構成は以下のとおり:\nwhile(式){文}\n式が真である場合，文を実行し，式の評価に戻る．偽の場合は直後のブロック{}の後にジャンプする． 式が定数式の場合は真偽が変わらないので，真ならば文を無限回実行するプログラムとなり，偽ならば文は一度も実行されない．\n以下は，入力された整数aとa+9の間の整数を出力するプログラム（の一部）である．\nint a, amax;\n\nprintf(\"整数を入力: \");\nscanf(\"%d\", &a);\n\namax = a + 9;\nwhile (a &lt;= amax) {\n  printf(\"%d \", a);\n  a = a + 1;\n}\nwhileの条件式に変数aが含まれており，繰り返し実行するブロック中でaの値が変更されていることに注意． 例えば，3行目で10が入力された場合，aは10，amaxは19である． while文のブロック中で，aは値を出力した後インクリメントされる． 10回目のループでaに20が代入されると，11回目の条件式評価ではa &lt;= amaxが偽となり，{}の中を実行することなく10行目のブロック直後にジャンプする．\n\n\n\n\n\n\n【再掲】無限ループを止める\n\n\n\n無限ループを含むプログラムを実行して入力を受け付けなくなってしまった場合は，ターミナル上でControl-CControl-Cを押すと止まる．",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#繰り返し-do-while",
    "href": "week03.html#繰り返し-do-while",
    "title": "3  C言語の復習 2",
    "section": "3.4 繰り返し do while",
    "text": "3.4 繰り返し do while\nwhile文と似ているが，ブロックを実行してから，その後に繰り返し条件式を判断する構文もある．\ndo{文}while(式);\nまず文を実行し，式が真であればもう一度，文を実行する．偽であれば次の行に移動する．\n次のプログラム（の一部）は入力された整数を出力する動作を繰り返す．\nint a;\ndo{\n  printf(\"整数を入力: \");\n  scanf(\"%d\", &a);\n  printf(\"--&gt; 入力された数: %d\\n\", a);\n  printf(\"終了する場合は 0 を入力: \");\n  scanf(\"%d\", &a);\n} while (a);\nwhile (a)は，aが真を表す値である0以外のとき条件式が真となりブロックの先頭に戻る． それ以外，つまり0のときは偽となり繰り返しを終了する．\n\n\n\n\n\n\n【再掲】真偽を表す数値\n\n\n\nC言語では，整数0が偽を表し，0以外は真を表す． 真を表す数値を明示的に書く場合には1がよく用いられるが，1以外も0でなければ真であることに注意．",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#インクリメント複合代入",
    "href": "week03.html#インクリメント複合代入",
    "title": "3  C言語の復習 2",
    "section": "3.5 インクリメント，複合代入",
    "text": "3.5 インクリメント，複合代入\n繰り返し文で1ずつ値を増加（減少）させたい場合は，増分演算子（減分演算子）を使うと短く記述できる．\n\na++ aの値を1だけ増加させる\na-- aの値を1だけ減少させる\n\nこのような動作をインクリメント（デクリメント）という． while文のサンプルプログラムでa = a + 1;としているところは，a++;に置き換えることができる．\nさらに，以下のように書くこともできる．\nwhile (a &lt;= amax) {\n  printf(\"%d \", a++);\n}\naの値をprintfに渡して出力してから，aの値を1増加させる動作をする． aの値を先に増加させてからprintfで出力したい場合は，++をaの前につける．\nwhile (a &lt;= amax) {\n  printf(\"%d \", ++a);\n}\nインクリメントの前置と後置はややこしいが，筆者の主観では後置を使うべき場面はそんなに多くない．\nインクリメントのように1ずつの増減に限らず，変数にある数を加える動作はよく使う． a = a + summandはa += summandと書くことができる．このような演算子を複合代入演算子と呼ぶ．\n\n\n\n用例\n意味\n\n\n\n\na += b\na = a + b\n\n\na -= b\na = a - b\n\n\na *= b\na = a * b\n\n\na /= b\na = a / b\n\n\na %= b\na = a % b\n\n\n\nこのほか，ビット演算子である&, |などに対応する複合代入演算子もある．\n\n\n\n\n\n\nNote\n\n\n\n数学で加減より乗除の計算が優先されるように，プログラミング言語の演算子にも優先順位がある． たとえばa * b &lt; 10は乗算*が比較&lt;より優先度が高いので，a*bの値が10より小さければ真となる（b &lt; 10の真偽値にaをかけることにはならない）．インクリメントや&&など複雑な式では動作が分かりづらくなるので，優先する動作を()で囲うとよい．",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#配列",
    "href": "week03.html#配列",
    "title": "3  C言語の復習 2",
    "section": "3.6 配列",
    "text": "3.6 配列\n同じデータ型をまとめて多数扱う場合には，配列として宣言するとよい． 配列を宣言するには，下記のように書く．\n型 変数名[要素数];\nたとえば，10名のテストの点数を格納する配列scoreは，\nint score[10];\nである．\n配列を宣言すると，データ型のバイト数✕配列要素数だけ連番でメモリ上に領域が確保される． 上の例では，intの4バイトを30個分，連続した領域が確保される． C言語では配列の宣言時にサイズを確定する必要がある2．\n配列の要素に値を代入するには次のように書く．\nscore[0] = 99;\nscore[1] = 80;\n配列の要素番号は0からスタートすることに注意が必要． つまり，配列の最後の要素の番号は，要素数-1である．\nscore[9] = 100;  // 10番目の要素\nscore[10] = 99;  // 実行時にエラー\n宣言と同時に値を代入する場合には，以下のように書く（配列の初期化という）．\nint score[] = {99, 80, 75, 66, 50, 87, 33, 89, 99, 100};\nscore[10]のように要素数を指定してもよいし，省略してもよい． ただし，省略できるのは宣言と同時に値を代入する場合に限る． 値を指定せずに宣言だけ行う場合には要素数を省略できない．\n\n\n\n\n\n\n2025/04/28 追記\n\n\n\n配列の要素数を指定して宣言し，宣言と同時に一部の要素を初期化した場合，値を指定していない残りの要素は0で初期化される． たとえば，\nint score[10] = {99, 80};\nのようにscore配列を宣言してscore[0]とscore[1]を99と80で初期化する．残りの要素score[3]からscore[9]は0で初期化される．これを応用して，scoreの値をすべて0で初期化したいときに\nint score[10] = {0};\nのように10個の0を並べることなく初期化できる．このような書き方は初期化のみ，つまり宣言と同時に値を代入するときのみ可能．また，値をひとつも指定しない場合は不定値で初期化されることに注意．\n\n\n配列の値は，変数名と要素番号を用いて参照できる．\nfor(int i = 0; i &lt; 10; i++){\n  printf(\"%d 番: %d点\\n\", i, score[i]);\n}\nここまで1次元の配列を考えたが，連番を2次元以上に設定することもできる． たとえば，前述の10名のテスト点数を5科目分に拡張したい場合は次のように書く．\nint score[5][10];\nこれは，score[0][0]→score[0][1]→…→score[0][9]→score[1][0]→…→score[4][9]のように先のインデックスが上位桁，後のインデックスが下位桁の連番となるようにメモリ領域を確保する．\n多次元配列の初期化は，要素ごとに値を代入するか，以下のように書く．\nint score[][10] = {\n  {99, 80, 75, 66, 50, 87, 33, 89, 99, 100},\n  {91, 98, 4,  4,  39, 68, 26, 26, 84, 6},\n  {92, 49, 94, 5,  80, 17, 70, 25, 55, 78},\n  {64, 81, 68, 10, 19, 12, 90, 93, 92, 94},\n  {99, 80, 75, 66, 50, 87, 33, 89, 99, 100}\n}; // 文末に ; を忘れないように\n2次元配列の要素を順番に出力するには，次のように2重ループを使う．\nint subject_num = 5;\nint student_num = 10;\n\nfor(int i = 0; i &lt; subject_num; i++){\n  printf(\"Subject no. %d\\n\", i);\n  for(int j = 0; j &lt; student_num; j++){\n    printf(\" %d\", score[i][j]);\n  }\n  printf(\"\\n\");\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#演習",
    "href": "week03.html#演習",
    "title": "3  C言語の復習 2",
    "section": "3.7 演習",
    "text": "3.7 演習\n以下の問題に取り組み，ソースコードをmanaba+Rにアップロードせよ．\n\n3.7.1 問題1\n行列の\\(A\\)をつぎのように定義する． \\[\n\\require{physics}\nA=\\mqty[1 & 1 & 3\\\\\n5 & 2 & 6\\\\\n-2 & -1 & -3]\n\\]\n\\(A^2\\)と\\(A^3\\)を計算して出力するプログラムnilpo.cを作成せよ．\n\n\n\n3.7.2 問題2\n銀行をひとつ選び，普通預金金利を調べよ．その金利に基づき，下記のとおり利息を付加する．1月1日に元本10万円を預け入れ，以後，30日おきに3万円を預け入れるとする3．1月1日を1日目とし，初めて100万円以上となるのは何日目かを出力するプログラムmillion.cを作成せよ．\n\n1日あたりの利息＝当日締めの預入残高×金利÷365 とする．ただし1円未満は切り捨てる\n半年複利とする\n\n上記で計算した利息を，半年に1回，2月15日（46日目）と8月15日（227日目）に元本に組み入れる\n\nうるう年は考慮せず，1年は必ず365日とする\n源泉徴収は考慮しない\n引き出しはしない\n\n出力例\n◯◯銀行に預けた場合 1234日 で100万円貯まります",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#footnotes",
    "href": "week03.html#footnotes",
    "title": "3  C言語の復習 2",
    "section": "",
    "text": "https://eeic-software1.github.io/2024/week1/↩︎\n1999年に制定された規格C99で配列のサイズを実行時に決定できるようになったが，それ以前は定数でなければならなかった．↩︎\n初回の預け入れは30日目の1月30日，2回目は60日目の3月1日↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week04.html",
    "href": "week04.html",
    "title": "4  C言語の復習 3",
    "section": "",
    "text": "4.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#前回演習の解答",
    "href": "week04.html#前回演習の解答",
    "title": "4  C言語の復習 3",
    "section": "",
    "text": "受講上の注意【再掲】\nインデントを揃える\n配列の初期化（追記）",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#本日のメニュー",
    "href": "week04.html#本日のメニュー",
    "title": "4  C言語の復習 3",
    "section": "4.2 本日のメニュー",
    "text": "4.2 本日のメニュー\n\n繰り返しの中断 break, continue\n関数\n二分法\nニュートン法",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#繰り返しを中断する",
    "href": "week04.html#繰り返しを中断する",
    "title": "4  C言語の復習 3",
    "section": "4.3 繰り返しを中断する",
    "text": "4.3 繰り返しを中断する\nswitch文の説明で既に登場しているが，breakを使うと，直近の繰り返し文を中断して抜けることができる． do while文の例文で学習した入力された整数を返す繰り返し文は，次のようにbreakを用いて書き改めることができる．\nwhile (1) { // 条件式は常に真なので無限ループ\n  printf(\"整数を入力: \");\n  scanf(\"%d\", &a);\n  printf(\"--&gt; 入力された数: %d\\n\", a);\n  printf(\"終了する場合は 0 を入力: \");\n  scanf(\"%d\", &a);\n  if ( a == 0 ) {\n    break; // while文を抜ける\n  }\n};\nたとえば配列の要素を順番に確認して，目的のものが見つかった時点でループを終了する場合に使う． 以下は，テストの点数配列scoreをチェックして100点の人がいる場合は特定の文字列を出力するプログラムである．\nint student_num = 10;\nint score[] = {99, 80, 75, 66, 50, 87, 33, 89, 99, 100};\nfor (int i = 0; i &lt; student_num; i++){\n    if (score[i] == 100){\n        printf(\"100点満点の人が存在します\\n\");\n        break;\n    }\n}\n似たような働きをする文に，continueがある．これは，ループの以後の文をスキップして次のループに移動する． 以下は，50点未満の人を除いて得点を出力するプログラムである．\nfor (int i = 0; i &lt; student_num; i++){\n    if (score[i] &lt; 50){\n        continue; // 50点未満は以下の処理をスキップ\n    }\n    printf(\"番号%dの得点: %d\\n\", i, score[i]);\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#関数",
    "href": "week04.html#関数",
    "title": "4  C言語の復習 3",
    "section": "4.4 関数",
    "text": "4.4 関数\n繰り返し同じ処理をする場合は，関数としてまとめて使い回すと効率が良いし，プログラムが読みやすくなる． 関数とは，渡された値（引数）を処理して何らかの値を返す（戻り値）ものであり，main関数やその他の関数から呼び出されたタイミングで実行される． 関数は以下のような構造で記述する．\n戻り値のデータ型 関数名(引数のデータ型 引数名){文}\n3つの整数を受け取って，最大値を返す関数max3を書いてみよう．\nint max3(int a1, int a2, int a3)\n{\n    int max = a1;\n    if (a2 &gt; max) {\n        max = a2;\n    }\n    if (a3 &gt; max) {\n        max = a3;\n    }\n    return max;\n}\n1行目より，これはint型のデータを返す関数で，関数名はmax3，引数はint型のa1およびa2, a3であることがわかる． ブロック{}内には関数で行う処理の本体が書かれている． a1, a2, a3のうち最大のものがmaxに代入されるようになっており，最後にmaxをreturnで戻り値に設定している． 引数のa1, a2, a3は，関数本体内で宣言せずに使用していることに注意． これは，1行目の関数宣言時にデータ型と変数名が確定しているため． 一方，maxは関数内で新たに定義する変数なので{}内でint変数として宣言している．\n関数の呼び出しは，以下のように書く．\n#include &lt;stdio.h&gt;\n\nint max3(int a1, int a2, int a3) {\n  int max = a1;\n  if (a2 &gt; max) {\n    max = a2;\n  }\n  if (a3 &gt; max) {\n    max = a3;\n  }\n  return max;\n}\n\nint main(void)\n{\n  int a, b, c;\n  int max;\n  printf(\"整数を3つ入力: \");\n  scanf(\"%d%d%d\", &a, &b, &c);\n  max = max3(a, b, c);\n  printf(\"最大値は%d\\n\", max);\n  return 0;\n}\n\n\n\n\n\n\n条件演算子\n\n\n\n条件演算子を用いた式「式1 ? 式2 : 式3」は，式1が真ならば式2を評価した結果を，式2が偽ならば式3を評価した結果を返す．これを用いると2値a1, a2の大きい方をmaxに代入する文はmax = (a1 &gt; a2) ? a1 : a2;と書ける．3値の最大値も同様にコンパクトに書けるが多少わかりにくい: max = (a1 &gt; a2) ? ((a1 &gt; a3) ? a1 : a3) : ((a2 &gt; a3) ? a2 : a3);\n\n\n関数max3はmainより前に記述されているが，Cプログラム実行時に最初に実行されるのはmain関数であるという決まりがあるので，まず，mainの1行目が実行される． 整数を3つ入力した後，main関数の5行目でmax3が呼び出される． ここで，main関数内での引数の変数名a, b, cと，関数max3の引数名a1, a2, a3は一致していなくてもよい（一致していてもよい）． 関数max3の呼び出し時に，\na1 = a;\na2 = b;\na3 = c;\nという代入が行われると理解しよう．当然，関数max3内でa1の値が書き換えられたとしても，max3を呼び出した元の関数のaは影響を受けない．このように関数の引数は呼び出し元とは別の変数であり，値が代入されることを値渡しという．\nmax3の戻り値は，main関数内で宣言されたmaxという変数に代入される． ここで，main関数における変数maxと，max3関数内で宣言された変数maxは別物であることに注意． 変数は宣言されたブロック内に限り有効である．このような，変数の有効範囲をスコープと呼ぶ．\nどのブロック内でもない場所で宣言された変数は，ファイル内全体で有効である． 同じ名前の変数が複数有効な場合，よりそのブロックに近い変数を指す．\n#include &lt;stdio.h&gt;\nint x = 1; // ファイル全体で有効な変数\nint main(void){\n  int x = 2; // mainブロック内のみで有効な変数\n}\n上のプログラムでは，main関数内では4行目で初期化されたx = 2が有効となる．\n関数には，戻り値が不要なものや引数が不要なものがある．その場合は，データ型のところにvoidと書く． 以下は，特定の文字列を出力する処理を関数として独立させたものである．\nvoid put_mytext(void){\n  printf(\"これは関数内の処理です\\n\");\n}\n\nint main (void)\n{\n  int num;\n  printf(\"何回書きますか？: \");\n  scanf(\"%d\", &num);\n  for (int i = 0; i &lt; num; i++){\n    put_mytext();\n  }\n  return 0;\n}\nmain関数の5行目で関数put_mytextが呼び出されているが，引数として何も渡していないので()となっている． また，戻り値も無いのでput_mytextにはreturn文が無い．",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#方程式の数値解法",
    "href": "week04.html#方程式の数値解法",
    "title": "4  C言語の復習 3",
    "section": "4.5 方程式の数値解法",
    "text": "4.5 方程式の数値解法\n方程式\\(f(x) = 0\\), \\(x \\in [\\underline{x}, \\bar{x}]\\)を数値的に解く方法を考えよう．ここで，「数値的に」とは，\\(f(x)=0\\)を式変形して\\(x = \\alpha\\)として\\(\\alpha\\)を求める方法ではなく，\\(x\\)に具体的な数字を代入して計算することによって解\\(\\alpha\\)を求めることを意味する．\n\n\n\n\n\nたとえば\\([\\underline{x}, \\bar{x}] = [-1, 1]\\)として，上図のような関数\\(f(x)\\)がプロットできる場合は，\\(x = -1, 0, 1\\)付近が解であることがわかるが，その厳密な値はグラフからはわからない．また，\\(f(x)\\)が複雑でグラフを描いても解が読み取れない，そもそもプロットできない場合を想定するとよい．\n\n4.5.1 二分法\n探索範囲を2分割して絞り込む方法である． アルゴリズムへの入力として，解を挟む閉区間\\([a, b]\\)と，解の許容誤差\\(\\epsilon\\)を与えておく． \\(a\\)と\\(b\\)の中点を新たに\\(c\\)として，\\(f(c)\\)の正負によって探索範囲を\\([a, c]\\)か\\([c, b]\\)に絞る．探索範囲の幅が\\(\\epsilon\\)より小さくなった時点で探索を終了する．\n\n\n\n\n\n\nTip\n\n\n\n探索範囲を\\([a, b]\\)の内点に限定してよい理由は，中間値の定理より: \\(f(x)\\)が閉区間\\([a, b]\\)上で連続であり，\\(f(a)\\neq f(b)\\)ならば，\\(f(a)\\)と\\(f(b)\\)の間の任意の値\\(\\xi\\)に対して\\(f(c) = \\xi\\)なる\\(c\\in[a, b]\\)が存在する． ここでは\\(\\xi = 0\\)と考えればよい．\n\n\n\n初期入力: \\(f(a)\\)と\\(f(b)\\)が異符号であるような\\(a, b \\in [\\underline{x}, \\bar{x}]\\)，正数\\(\\epsilon\\)\n手順1: \\(c := (a + b)/2\\)とする．もし\\(f(c) = 0\\)ならば\\(c\\)を解として終了． もし\\(f(a)\\)と\\(f(c)\\)が異符号ならば\\(b \\leftarrow c\\)とする．もし\\(f(b)\\)と\\(f(c)\\)が異符号ならば\\(a \\leftarrow c\\)とする．\n手順2: \\(|b-a| &lt; \\epsilon\\)ならば\\(a, b\\)（またはその中点）を解として終了．そうでなければ手順1へ．\n\n以下は，\\(f(x) = x^2 -2 = 0\\)の解を，\\(a=0\\), \\(b = 2\\)を初期探索範囲として求めるプログラムである． ただし，二分法のアルゴリズム部分は実装していない（後の演習問題とする）．\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;  // 絶対値を求める関数 fabs を使用するため必要\n\n// 解きたい方程式 f(x) = x^2 - 2 = 0\ndouble f(double x) {\n  return x * x - 2;\n}\n\ndouble bisection_search(double a, double b, double eps) {\n  double c;\n  // 二分法の探索アルゴリズム\n  return c;\n}\n\nint main(void) {\n  double a = 0.0, b = 2.0, eps = 0.01;\n  if (f(a) * f(b) &gt; 0) {\n    printf(\"この範囲に解はありません\\n\");\n    return 0;\n  }\n  if (f(a) == 0 || f(b) == 0) {\n    if (f(a) == 0) {\n      b = a;\n    } else {\n      a = b;\n    }\n  } else {\n    a = bisection_search(a, b, eps);\n  }\n\n  printf(\"解はx = %lf\\n\", a);\n  return 0;\n}\n\n\n\n\n\n\n指数の数学的表記\n\n\n\n\\(0.0001 = 10^{-4}\\)のように0が長く続く数値は1e-4のように表記できる．1E-4, 1.0e-4でも可．同様に\\(10000\\)は1e4, 1E4, 1.0e+4のように表すことができる．いずれもdouble型となり，そのままではint型には代入できない．\n\n\n1回の反復で探索範囲\\([a,b]\\)が半分になるから，探索範囲の長さが\\(\\epsilon\\)より小さくなる反復回数を\\(N\\)とすると， \\[\n\\require{physics}\n\\frac{b-a}{2^N} &lt; \\epsilon\n\\Leftrightarrow N &gt; \\log_2\\qty(\\frac{|b-a|}{\\epsilon})\n\\] である．\n\n\n4.5.2 ニュートン法\n\n\n\n\n\n方程式\\(f(x) = 0\\)の解を求めるために，\\(f'(x)\\)が計算可能な場合を考えよう． ここで「\\(f'(x)\\)が計算可能」とは，\\(x\\)を具体的にひとつ決めれば対応する微分係数\\(f'(x)\\)を計算できるという意味である． 微分が計算できるなら，赤線のグラフを1次関数として近似できる．1次方程式の解は簡単に計算できるので，その解を近似解として採用すればよいのでは？ これをニュートン法と呼ぶ．\n初期解\\(x_0\\)を適当に定義域上に定め（上図では\\(x_0=1.2\\)），その点における勾配\\(f'(x_0)\\)を計算すれば，接線が求まる（上図の青線）． 接線が\\(x\\)軸と交わる点を新たな解の候補\\(x_1\\)とする（上図では\\(x_1 = 1.04096\\)）． これを繰り返せば，点列\\(x_n\\)は\\(f(x)=0\\)の解に近づくと期待できる．\n\n\n\n\n\n点\\(x_n\\)における接線の方程式は \\[\ny = f'(x_n)(x-x_n) + f(x_n)\n\\] であるから，この1次式が\\(x\\)軸と交わる点\\(x_{n+1}\\)は，\\(y=0\\)を\\(x\\)について解いて， \\[\nx_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}\n\\] となる．\n初期解\\(x_0\\)が解\\(\\alpha\\)に十分近いときにはニュートン法によって\\(x_n\\)は\\(\\alpha\\)に2次収束する． つまり，\\(x_n\\)が\\(\\alpha\\)に十分近いときには，ある\\(c&gt;0\\)を用いて \\[\n|x_{n+1} - \\alpha| \\approx c |x_n - \\alpha|^2\n\\] となる．\n探索の終了条件は，\\(f(x_n)\\)が0に十分近くなった場合や，解の候補がほとんど動かなくなった場合，つまり\\(x_{n+1}-x_n\\)が十分小さくなった場合とする: \\[\n|f(x_n)| &lt; \\epsilon \\quad\\text{or}\\quad |x_{n+1}-x_n| &lt; \\delta.\n\\]\n解の更新部分を除く実装例は以下の通り．\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\ndouble f(double x) {\n  return x * x - 2;\n}\ndouble dfdx(double x) {\n  return 2 * x;\n}\ndouble newton_search(double x, double eps, double dlt) {\n  double xnext;\n  // ニュートン法の探索アルゴリズム\n  return xnext;\n}\n\nint main(void) {\n  double x0 = 2.0, eps = 0.01, dlt = 0.01;\n  printf(\"解はx = %lf\\n\", newton_search(x0, eps, dlt));\n  return 0;\n}\n\n\n\n\n\n\nニュートン法の問題点\n\n\n\n初期解を解の十分近くに取る必要性に加え，\\(f'(x_n)\\)の逆数を解の更新に用いる点は，ニュートン法を適用するうえでしばしば障害となる．\\(f'(x_n)=0\\)となる場合に計算不能となるのはすぐわかる． 独立変数\\(x\\)が多次元の場合は，\\(f(x)\\)のヤコビ行列の逆行列を計算することに相当し，どの\\(x_n\\)に対してもこの逆行列の存在を保証することはハードルが高い．また，逆行列計算の計算量の多さも問題となる． そこで，\\(f'(x_n)\\)を近似的に計算するニュートン法の改良法が数多く提案されている． \n\n\n\n\n\n\n\n\n反復アルゴリズム\n\n\n\nニュートン法のように，解の候補\\(x_n\\)を\\(f(x_n)\\)や\\(f'(x_n)\\)の値を用いて更新するアルゴリズムは非常に広範囲で使われる． 一般的な形式で書き表すと， \\[\nx_{n+1} = x_n + \\alpha_n \\Delta x_n\n\\] の様に書け，\\(\\Delta x_n\\)は解を更新する方向を，\\(\\alpha_n\\)はどの程度解を動かすかを表している． 初見の数値解法アルゴリズムであっても，上式のように解釈すると意味がわかりやすい．",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#演習",
    "href": "week04.html#演習",
    "title": "4  C言語の復習 3",
    "section": "4.6 演習",
    "text": "4.6 演習\n\n4.6.1 問題1\nつぎのプログラムを実行し，出力される値を理由とともに説明せよ．ファイル名をscope.txtとする．\n#include &lt;stdio.h&gt;\n\nint x = 1;\n\nvoid print_x(void) {\n  int x = 10;\n  printf(\"%d\\n\", x);\n}\n\nint main(void) {\n  printf(\"%d\\n\", x);\n  int x = 100;\n  print_x();\n  for (int i = 0; i &lt; 3; i++) {\n    int x = 1000 + i;\n    printf(\"%d\\n\", x);\n    x++;\n  }\n  return 0;\n}\n\n\n\n4.6.2 問題2\n二分法の探索プログラムを完成させ，\\(\\cos(x / 2) = 0\\)の解を\\(x\\in[0, 6]\\)の間で求めよ．ファイル名はbisection.cとする．\n\n\n\n\n\n\n絶対値関数\n\n\n\n絶対値を求めるには，math.hをincludeしてfabs関数を使う．この関数はdouble型を引数として，その絶対値をdobule型で返す．\ndouble fabs(double)\nmath.hで定義されている関数一覧はこのページなどを参照．\n\n\n\n\n\n\n\n\n数学関数を使う場合のコンパイルエラー\n\n\n\nmath.hで宣言されている数学関数を使用すると，コンパイル時にエラーとなる場合がある．その場合は，lmオプションを付ける．\ngcc bisection.c -lm\n\n\n\n\n4.6.3 問題3\nニュートン法の探索プログラムを完成させ，\\(\\cos(x / 2) = 0\\)の解を\\(x\\in[0, 6]\\)の間で求めよ．ファイル名はnewton.cとする．",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week05.html",
    "href": "week05.html",
    "title": "5  C言語の復習 4",
    "section": "",
    "text": "5.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#本日のメニュー",
    "href": "week05.html#本日のメニュー",
    "title": "5  C言語の復習 4",
    "section": "5.2 本日のメニュー",
    "text": "5.2 本日のメニュー\n\nマクロ\n文字，文字列",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#include指令",
    "href": "week05.html#include指令",
    "title": "5  C言語の復習 4",
    "section": "5.3 include指令",
    "text": "5.3 include指令\nコンパイラがソースコードを機械語に変換する前に，プリプロセッサがソースコードを編集する． このときの動作について説明する．\n#include &lt;ファイル名&gt;があるとき，その場所にファイル名で指定したファイルの中身が挿入される． 既存のライブラリ（のヘッダファイル）など，システム上のファイルを指定する場合はファイル名を&lt;と&gt;で囲う． 自作のファイルを読み込む場合はファイルパスを\"で囲う．",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#define指令オブジェクトマクロ",
    "href": "week05.html#define指令オブジェクトマクロ",
    "title": "5  C言語の復習 4",
    "section": "5.4 define指令（オブジェクトマクロ）",
    "text": "5.4 define指令（オブジェクトマクロ）\n#define a bと書くと，これ以降のaはbに置換される（ただし，\"で囲われた中身（文字列リテラル），変数名の一部は置換されない）． これをオブジェクトマクロと呼ぶ． プログラム中で使用する定数（プログラム実行中に書き換えることのない値）に名前をつけて可読性を上げたり，定数を変更する際の手間を省いたりするのに役立つ． たとえば，学生数分の配列を使う場合，下記のように書くことができる．\n#define STUDENT_NUM 30\nint main(void){\n    int score[STUDENT_NUM]; //コンパイルの前に int score[30] に置き換えられる\n    // ...\n    for(int i = 0; i &lt; STUDENT_NUM; i++) \n    // ...\n}\nオブジェクトの名前は，変数と区別するために大文字アルファベットで記述することが多い．\n#define PI 3.14159",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#define指令関数形式マクロ",
    "href": "week05.html#define指令関数形式マクロ",
    "title": "5  C言語の復習 4",
    "section": "5.5 define指令（関数形式マクロ）",
    "text": "5.5 define指令（関数形式マクロ）\nマクロを使って関数のようなものを定義できる． たとえば，2乗するマクロは以下の通り．\n#define SQR(x) ((x) * (x))\nint main(void){\n    int a = SQR(2); // a = ((2) * (2)) に置換され a = 4 となる\n}\n関数形式（int sqr(int x){ return x*x; }）と比較すると，型を限定しない関数（ぽいもの）を定義できるという利点がある． 例えば，上のSQR()は，\nint a = 2;\nprintf(\"%d\\n\", SQR(a));  // int型の変数を2乗\ndouble b = 2.2;\nprintf(\"%lf\\n\", SQR(b)); // double型の変数を2乗\nのように使うことができる．\n同様に2変数関数も作ることができる．\n#define MAX2(x,y) (x &gt; y ? x : y)\nここで，定義部分は条件演算子と呼ばれ，(条件式 ? 条件式が真の場合の値 : 条件式が偽の場合の値)という書式である．\nマクロには利点がある一方で，意図しない動作をする恐れがある点に注意が必要である． 例えばSQR(a++)は((a++) * (a++))に置換されることから，単にaの2乗を計算してからaをインクリメントするのではなく，インクリメントが2回行われる． もう一つの例として，\n#define NIBAI(x) (x * 2)\nint main(void){\n    printf(\"%d\\n\", NIBAI(3+4)); // 3+4 * 2 と展開される\n}\nとすると，NIBAI(3+4)は3+4 * 2と展開される． よって，おそらく想定していた\\(3+4 = 7\\)の2倍である\\(14\\)とは異なり，値は\\(3+8=11\\)となる．",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#ifdef指令",
    "href": "week05.html#ifdef指令",
    "title": "5  C言語の復習 4",
    "section": "5.6 ifdef指令",
    "text": "5.6 ifdef指令\nもうひとつ#を使う指令として，ifdefを紹介する． これを使うと，特定の名前のマクロが定義済みか否かによってプログラムの実行を分岐させることができる．\n#define マクロ名 値\n// ...\n#ifdef マクロ名\n  「マクロ名」が定義済みの場合にのみ，この部分を実行\n#endif\nたとえば，デバッグ用にprintf文を仕込んだとき，それを実行するか否かをマクロの有無で切り替えることができる．\n#define IS_DEBUG_MODE // デバッグモードでないときはコメントアウト\nint main(void){\n    #ifdef IS_DEBUG_MODE\n        printf(\"デバッグ用メッセージ\");\n    #endif\n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#文字",
    "href": "week05.html#文字",
    "title": "5  C言語の復習 4",
    "section": "5.7 文字",
    "text": "5.7 文字\n文字1字を表すにはchar型の変数を使う．1文字を表現するにはその文字を単引用符（'）で囲う． printfでchar型の文字を出力するには%cで書式指定する．\nchar moji = 'a'; // 文字「a」を変数mojiに代入\nprintf(\"%c\\n\", moji); // a を出力\ncharは1バイト分の整数（\\(0\\)–\\(255\\)または\\(-128\\)–\\(127\\)）を表現可能な型である． つまり，文字は，文字に対応する整数値で変数に保存される．\nchar moji = 'a';\nprintf(\"%d\\n\", moji); // 文字「a」に対応する数字 97 を出力\nこの整数値はASCII（アスキー）コードと呼ばれる．その一部を別表に示す．\n\n\n\n\n\n\nマルチバイト文字\n\n\n\nここでは文字として半角英数と記号(!\"#$%&'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~)を考える． 日本語の文字は1バイトでは表現できず，1文字を2バイト以上で表現する． 文字と数字の対応は文字コードに依存する．\n\n\n逆に，文字に対応する整数値を指定すれば，文字を表現することができる．\nchar moji = 97; // 整数値97を代入\nprintf(\"%c\\n\", moji); // 書式を%cで指定すると対応する文字「a」を出力\nASCIIコードを確認するとわかるが，連続するアルファベットは連続する数値が割り当てられている． また，Aとaは異なる文字なので，対応する数字も異なる．",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#文字列の基本",
    "href": "week05.html#文字列の基本",
    "title": "5  C言語の復習 4",
    "section": "5.8 文字列の基本",
    "text": "5.8 文字列の基本\n文字列は，文字の配列で表現する．つまりchar型の配列である． 文字を二重引用符（\"）で囲うと文字列を表す． このように，ソースコード上の\"で囲われた文字列の表現のことを文字列リテラルと呼ぶ．\nchar str[4] = \"abc\"; // 配列strを文字列リテラルで初期化\nprintfで書式指定を%sとすると，与えられた配列の文字列を出力する．\nprintf(\"%s\\n\", str); // 文字列に対応する書式指定は %s\nここで，配列strのサイズが4であることに注意する． これは，文字列は末尾に終端を意味する不可視の記号（NULL文字）を含むため． NULL文字は'\\0'と表現する．\nつまり，文字列の初期化\nchar str[4] = \"abc\";\nを文字に分解して書き表すと\nchar str[4] = {'a', 'b', 'c', '\\0'};\nとなり，両者の意味するところは同一である．\n\n\n\n\n\n\n文字列の末尾にはNULL文字が必要\n\n\n\n末尾にNULL文字が無い文字列はC言語の仕様に適さない．\nchar str[] = {'a', 'b', 'c'};\nprintf(\"%s\\n\", str);\nとすると，abcに続いて変な文字が出力される．",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#配列としての文字列",
    "href": "week05.html#配列としての文字列",
    "title": "5  C言語の復習 4",
    "section": "5.9 配列としての文字列",
    "text": "5.9 配列としての文字列\n文字列は配列であるから，普通の配列と同様に要素ごとに参照や代入が可能である．\nchar str[] = \"abc\"; // 配列を宣言と同時に初期化する場合はサイズを省略できる\n\n// 文字列として出力\nprintf(\"%s\", str); // abc\nprintf(\"\\n\");\n\n// 1要素ずつ文字として出力\nfor(int i = 0; i &lt; 4; i++){\n    printf(\"%c, \", str[i]); // a, b, c\n}\nprintf(\"\\n\");\n\n// 1要素ずつ数値として出力\nfor(int i = 0; i &lt; 4; i++){\n    printf(\"%d, \", str[i]); // 97, 98, 99\n}\nprintf(\"\\n\");\n通常の配列と同様，初期化以外で一括代入はできない．\nchar str[4];\nstr = \"abc\"; // エラー\n文字列の途中にNULL文字がある場合，最初のNULL文字までが文字列となる． たとえば\"abc\\0def\"という文字列リテラルで初期化した配列を文字列として認識した結果はabcである．\nchar str[] = \"abc\\0def\";\nprintf(\"%s\\n\", str); // abc\n\n\n\n\n\n\nNote\n\n\n\n文字列を初期化するときに，サイズ数より大きい文字列リテラルを代入するとNULL文字が入り切らずに切り取られて不正な文字列になるので注意．\nchar str[4] = \"abcd\"; // dの後のNULL文字が入りきらない\nprintf(\"%s\\n\", str);  // 意図しない出力\n逆に配列のサイズが初期化文字列より大きい場合は，残りの配列要素が0，つまりNULL文字で埋められるので，問題は生じない．\nchar str[10] = \"abcd\"; // 5番目以降は 0 = '\\0' で初期化\nprintf(\"%s\\n\", str);   // abcd",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#文字列の組",
    "href": "week05.html#文字列の組",
    "title": "5  C言語の復習 4",
    "section": "5.10 文字列の組",
    "text": "5.10 文字列の組\n複数の文字列はchar型の2次元配列で扱うことができる．\nchar name[][11] = {\"Alice\", \"Bob\", \"Charlie\"}; // 長さ11(= 10字+NULL文字)の文字の組を格納する2次元配列\nこの2次元配列の要素は下記のようである．\nname[0][0] = 'A', name[0][1] = 'l', name[0][2] = 'i',  name[0][3] = 'c', name[0][4] = 'e', name[0][5] = '\\0', ..., name[0][10] = '\\0',\nname[1][0] = 'B', name[1][1] = 'o', ...,\nname[2][0] = 'C', name[2][1] = 'h', ..., name[2][10] = '\\0'\n2次元配列の文字列を順に出力するプログラム（の一部）は以下の通り．\nchar name[][11] = {\"Alice\", \"Bob\", \"Charlie\"};\nfor(int i = 0; i&lt; 3; i++){\n    printf(\"%s\\n\", name[i]); // [i]が必要なことに注意\n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#文字列の読み込み",
    "href": "week05.html#文字列の読み込み",
    "title": "5  C言語の復習 4",
    "section": "5.11 文字列の読み込み",
    "text": "5.11 文字列の読み込み\nscanf関数でユーザーの入力を文字列として読み込むことができる．\n#include &lt;stdio.h&gt;\n#define MAX_CHAR 10\nint main(void){\n    char str[MAX_CHAR+1];\n    printf(\"文字列を入力してください:\");\n    scanf(\"%s\", str); // %s = 文字列として解釈, &をつけないstr\n    printf(\"%s と入力しましたね\\n\", str);\n    return 0;\n}\nこのとき，scanfに渡すstrに&が不要である点に注意． これは，配列名は配列先頭のアドレスを表すためであり，（配列ではない）変数にアドレス演算子&をつけたものと同種の情報を渡していることになる．\n\n\n\n\n\n\nscanfはスペースを区切り文字として扱う\n\n\n\nscanfはスペースで入力を区切るので，ユーザーがスペースを入力すると，その後の文字列はstrに格納されない． スペース（や改行）を含めて読み取るには，ファイル入出力に使うfgets関数を使うとよい．\nfgets(str, sizeof(str), stdin); // 読み込み先の配列，配列サイズ，読み込み元 (stdinは標準入力)\nprintf(\"%s と入力しましたね\\n\", str);",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#stringライブラリの便利関数",
    "href": "week05.html#stringライブラリの便利関数",
    "title": "5  C言語の復習 4",
    "section": "5.12 stringライブラリの便利関数",
    "text": "5.12 stringライブラリの便利関数\nstring.hには文字列関係の便利な関数が定義されている． いくつか紹介する．\n\n5.12.1 文字列の長さ\n\nstrlen(文字列): NULL文字を除く文字列の長さを返す\nstrcpy(配列名, 文字列): 配列名に文字列をコピーする\nstrcat(配列名, 文字列): 配列名内の文字列末尾に文字列を結合する\nstrcmp(文字列1, 文字列2): 文字列1と2を辞書式に大小比較し，文字列1が文字列2より小さい場合に負の整数，等しい場合に0，文字列1が文字列2より大きい場合に正の整数を返す\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint main(void) {\n  // 文字列の長さ\n  char s1[] = \"abc\";\n  unsigned int len = strlen(s1); // 文字列の長さを返す(NULL文字を除く)\n  printf(\"%d\\n\", len);\n  printf(\"%lu\\n\", sizeof(s1)); // sizeof(配列名)で配列のバイト数を返す. unsigined longなので%lu\n\n  // 文字列のコピー\n  char s2[10];\n  strcpy(s2, s1);     // s2にs1をコピー\n  printf(\"%s\\n\", s2); // abc\n\n  // 文字列の結合\n  char s3[10] = \"xyz\";\n  strcat(s3, s1);     // s3の後にs1を連結 (s3は十分長くとっておく)\n  printf(\"%s\\n\", s3); // xyzabc\n\n  // 文字列の比較\n  char s4[10] = \"abcd\";\n  int cmp1 = strcmp(s1, s4);    // s1 &lt; s2, 負\n  int cmp2 = strcmp(s1, \"abc\"); // s1 == s2, 0\n  printf(\"%d, %d\\n\", cmp1, cmp2);\n  \n  return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#演習",
    "href": "week05.html#演習",
    "title": "5  C言語の復習 4",
    "section": "5.13 演習",
    "text": "5.13 演習\n\n5.13.1 問題1\nユーザーが入力した文字列のうち，大文字アルファベットを小文字に，小文字アルファベットを大文字に変換するプログラムを作成せよ． 入力する文字列の最大数をマクロで定義すること． 入力は改行とスペースを含まない1行としてよい． ファイル名をalphabet.cとする．\n\nテスト入力: ABCdef&lt;=&gt;uVwXyZ\nテスト出力: abcDEF&lt;=&gt;UvWxYz\n\n\n\n5.13.2 問題2\n0, '0', \\0, \"0\", \"\\0\"の違いを説明せよ． ファイル名をq2.txtとする．",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#asciiコード",
    "href": "week05.html#asciiコード",
    "title": "5  C言語の復習 4",
    "section": "5.14 ASCIIコード",
    "text": "5.14 ASCIIコード\n\n\n\n文字コード (10進数)\n文字コード (2進数)\n文字\n\n\n\n\n0\n0000 0000\n(NULL)\n\n\n…\n…\n制御文字\n\n\n10\n0000 1010\n\\n (LF)\n\n\n…\n…\n制御文字\n\n\n32\n0010 0000\n(space)\n\n\n…\n…\n数字と記号\n\n\n65\n0100 0001\nA\n\n\n66\n0100 0010\nB\n\n\n67\n0100 0011\nC\n\n\n68\n0100 0100\nD\n\n\n69\n0100 0101\nE\n\n\n70\n0100 0110\nF\n\n\n71\n0100 0111\nG\n\n\n72\n0100 1000\nH\n\n\n73\n0100 1001\nI\n\n\n74\n0100 1010\nJ\n\n\n75\n0100 1011\nK\n\n\n76\n0100 1100\nL\n\n\n77\n0100 1101\nM\n\n\n78\n0100 1110\nN\n\n\n79\n0100 1111\nO\n\n\n80\n0101 0000\nP\n\n\n81\n0101 0001\nQ\n\n\n82\n0101 0010\nR\n\n\n83\n0101 0011\nS\n\n\n84\n0101 0100\nT\n\n\n85\n0101 0101\nU\n\n\n86\n0101 0110\nV\n\n\n87\n0101 0111\nW\n\n\n88\n0101 1000\nX\n\n\n89\n0101 1001\nY\n\n\n90\n0101 1010\nZ\n\n\n91\n0101 1011\n[\n\n\n92\n0101 1100\n\\\n\n\n93\n0101 1101\n]\n\n\n94\n0101 1110\n^\n\n\n95\n0101 1111\n_\n\n\n\n\n\n\n文字コード (10進数)\n文字コード (2進数)\n文字\n\n\n\n\n96\n0110 0000\n`\n\n\n97\n0110 0001\na\n\n\n98\n0110 0010\nb\n\n\n99\n0110 0011\nc\n\n\n100\n0110 0100\nd\n\n\n101\n0110 0101\ne\n\n\n102\n0110 0110\nf\n\n\n103\n0110 0111\ng\n\n\n104\n0110 1000\nh\n\n\n105\n0110 1001\ni\n\n\n106\n0110 1010\nj\n\n\n107\n0110 1011\nk\n\n\n108\n0110 1100\nl\n\n\n109\n0110 1101\nm\n\n\n110\n0110 1110\nn\n\n\n111\n0110 1111\no\n\n\n112\n0111 0000\np\n\n\n113\n0111 0001\nq\n\n\n114\n0111 0010\nr\n\n\n115\n0111 0011\ns\n\n\n116\n0111 0100\nt\n\n\n117\n0111 0101\nu\n\n\n118\n0111 0110\nv\n\n\n119\n0111 0111\nw\n\n\n120\n0111 1000\nx\n\n\n121\n0111 1001\ny\n\n\n122\n0111 1010\nz\n\n\n123\n0111 1011\n{\n\n\n124\n0111 1100\n|\n\n\n125\n0111 1101\n}\n\n\n126\n0111 1110\n~\n\n\n127\n0111 1111\nDEL",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week06.html",
    "href": "week06.html",
    "title": "6  C言語の復習 5",
    "section": "",
    "text": "6.1 おしらせ",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#おしらせ",
    "href": "week06.html#おしらせ",
    "title": "6  C言語の復習 5",
    "section": "",
    "text": "次週の授業について",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#本日のメニュー",
    "href": "week06.html#本日のメニュー",
    "title": "6  C言語の復習 5",
    "section": "6.2 本日のメニュー",
    "text": "6.2 本日のメニュー\n\nポインタ",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#ポインタの基本",
    "href": "week06.html#ポインタの基本",
    "title": "6  C言語の復習 5",
    "section": "6.3 ポインタの基本",
    "text": "6.3 ポインタの基本\nポインタとは，他の変数のメモリアドレスを格納する変数である． ポインタ変数ともいう．ポインタのデータサイズは，64ビットマシンなら64ビット（8バイト）である．\nポインタを宣言するには，データ型 *ポインタ名と書く． 例えば，int型のポインタは以下のように宣言する．\nint a = 10;\nint *p; // int変数へのポインタを宣言\np = &a; // 変数aのアドレスをpに格納\n3行目で，&は変数のアドレスを抽出する演算子なので，pにはaのアドレスが格納される．データを確認してみよう．printfでアドレスを出力する書式指定は%pである．\nprintf(\"%p\\n\", &a); // 0x16b386c88 (変数aのアドレス)\nprintf(\"%p\\n\", p);  // 0x16b386c88 (9桁しかないのは上の桁が0で省略されているため)\n2行目で，pの前には&がついていないことに注意．\nポインタに*をつけると，ポインタが指している変数（つまり，ポインタ変数に格納されているアドレスの変数）と同じ様に扱うことができる．*を間接演算子と呼ぶ．\nint a, b;\nint *p;  // int型へのポインタを宣言\na = 10;\np = &a;  // pにaのアドレスを格納\nb = *p;  // b = a;と同じ\n*p = 20; // a = 20と同じ\nprintf(\"%d\\n\", a);   // 20\nprintf(\"%d\\n\", *p);  // 20\n\n\n\n\n\n\n*をつけてポイント先の変数にアクセス\n\n\n\nこのときの*は，ポインタ変数宣言時の*とは全く別物である． 変数宣言時の\nint *p;\nは，意味的には\nint* p;\nつまり，int型データのアドレスを格納するint*型変数を宣言していると考えるとよい． 実際，int型変数は4バイト，ポインタ変数は8バイト1の変数で別物である．\n\n\n\n\n\n\n\n\nTip\n\n\n\nポインタ変数pをint* p;と宣言することも可能だが，複数個のポインタ変数をまとめて宣言する場合に直観に反する動作をするので，書き方としてはint *p;を推奨する．\nint* p1, p2, p3; // int *p1, p2, p3; と解釈される\nは，p1はポインタ，p2とp3はint型変数となる．\n\n\n\n\n\n\n\n\nTip\n\n\n\n通常の変数に対して*を使うことはできない．\nint a = 10;\n*a; // コンパイル時にエラー",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#関数の引数にポインタを使う",
    "href": "week06.html#関数の引数にポインタを使う",
    "title": "6  C言語の復習 5",
    "section": "6.4 関数の引数にポインタを使う",
    "text": "6.4 関数の引数にポインタを使う\n関数がreturnで返すことができるデータは1つだけであるが，ポインタを使うと2つ以上の値を得ることができる．\nつぎの例は，2つの変数a, bを受け取って2種類の計算a+bとa-bを行う関数sum_diffを定義している．\n#include &lt;stdio.h&gt;\nvoid sum_diff(int a, int b, int *add, int *diff) {\n  *add = a + b;  // ポインタaddの指すアドレスに値を書き込む\n  *diff = a - b; // ポインタdiffの指すアドレスに値を書き込む\n}\n\nint main(void) {\n  int ad, df; // 戻り値を格納するint型変数\n  sum_diff(10, 100, &ad, &df); // 戻り値用の *アドレス* を関数に渡す\n  printf(\"a-b: %d, a-b: %d\\n\", ad, df);\n  return 0;\n}\n関数の引数int *add, int *diffは計算結果の格納用で，int型のポインタとして受け取っている． 呼び出し元のmain関数では，戻り値の書き込み先のアドレス&ad, &dfを渡している（9行目）．関数sum_diff内では，*演算子を使ってアドレスで参照している先，つまりmainで宣言された変数にアクセスして計算結果を書き込んでいる．\nここで，関数の引数をポインタとせず，通常のint変数で渡すと，エラーにはならないが意図した動作は実現できない． これは，ポインタではない通常の変数を関数に渡すときには，関数内の変数に値がコピーされ，呼び出し元とは別の領域にデータが格納されるためである．これを値渡しという． これに対して，呼び出し元で用意したデータ格納先のアドレスを渡すと，関数内から呼び出し元の変数にアクセスすることができる．これを参照渡しと呼ぶ．\n値渡しと参照渡しの動作の違いを確認するため，渡された2つの数字を入れ替える関数の実装例を見てみよう．\n#include &lt;stdio.h&gt;\nvoid swap1(int a, int b) {// aとbを入れ替える（値渡し）\n  int tmp = a;\n  a = b;\n  b = tmp;\n}\n\nvoid swap2(int *a, int *b) {// aとbを入れ替える（参照渡し）\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint main(void) {\n  int a = 1;\n  int b = 10;\n  swap1(a, b);  // 値渡し\n  printf(\"swap 1: a = %d, b = %d\\n\", a, b); // 入れ替わらない\n\n  a = 1;\n  b = 10;\n  swap2(&a, &b); // 参照渡し\n  printf(\"swap 2: a = %d, b = %d\\n\", a, b); // 入れ替わる\n\n  return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#ポインタと配列",
    "href": "week06.html#ポインタと配列",
    "title": "6  C言語の復習 5",
    "section": "6.5 ポインタと配列",
    "text": "6.5 ポインタと配列\n\n6.5.1 ポインタで配列を走査\n配列は，メモリ上に連番で格納領域を確保するので，連続したアドレスが並ぶことになる．\nint a[3] = {0, 1, 2};\nint *p = &a[0];\n上の例では，ポインタpに配列の先頭a[0]のアドレスが格納される．\nここでpの値を1だけ増加させる．すると，pの値はint型データ1つ分のアドレス（つまり4バイト分）が加算され，a[1]のアドレスと一致する．\np++;                // pをインクリメント\nprintf(\"%d\\n\", *p); // 1 (=a[1])\n同様に，aがdouble型の配列でpがdouble型へのポインタであれば，pに1を加えるとdouble型データ1つ分のアドレス（つまり8バイト分）が加算される．\n#include &lt;stdio.h&gt;\nint main(void) {\n  double a[] = {0.0, 1.0, 2.0};\n  double *p, *q;\n\n  p = &a[0];\n  q = p + 1;\n  printf(\"%lf\\n\", *q);      // 1.0 (=a[1])\n  printf(\"%p, %p\\n\", p, q); // 0x16cf4ec70, 0x16cf4ec78\n  return 0;\n}\n\n\n6.5.2 配列名とアドレス\n第05回で触れたが，配列名単独は，配列の先頭を表すアドレスを意味する．\nint a[] = {0, 1, 2};\nint *p;\np = a; // p = &a[0]と同じ\nまた，配列要素のアドレスは配列名 + インデックス番号と書くことができる． これは，配列名がその配列の先頭へのポインタであることを考えると納得できるであろう．\na;     // = &a[0]\na + 1; // = &a[1]\na + 2; // = &a[2]\nこれを利用して，配列aのi番目要素を*(a + i)のように参照することができる．\n*(a + 1) = 0; // a[1]に 0 を代入\nまとめると，配列aのインデックス1番目を参照する方法として，以下の3種類は同じ意味である．\nint a[] = {0, 1, 2};\nint *p = &a[1]; // a[1]へのポインタ\na[1];     // a[1]の値\n*p;       // a[1]の値\n*(a + 1); // a[1]の値\n\n\n6.5.3 配列を引数とする関数\n配列を引数とする関数は次のように定義する．\n// 配列とその長さを受け取って，すべての要素を出力する関数\nvoid print_array(int a[], int n){\n  for(int i = 0; i &lt; n; i++){\n    printf(\" %d\", a[i]);\n  }\n  printf(\"\\n\");\n}\nこれは，配列先頭へのポインタを渡す関数としても定義できる．\n// 上の関数の引数の表現をポインタに変えたもの\nvoid print_array(int *a, int n){\n  for(int i = 0; i &lt; n; i++){\n    printf(\" %d\", a[i]);\n  }\n  printf(\"\\n\");\n}\nここで，関数の中身（3–6行目）は全く同一であることに注意．つまり，ポインタpに対してp[i]との表記も可能であり，これは*(p + i)を表す．\n\n\n\n\n\n\nTip\n\n\n\n関数の引数を配列形式int a[]とするかポインタ形式int *aとするかは，読ませたい意図によって使い分けることが多いようである．つまり，配列としての意味を強調したいのか，ポインタとして読ませたいかに依る． いずれの場合でも，配列のサイズを超えてアクセスすることがないように，配列のサイズを併せて関数に渡す．\n\n\n配列名とポインタが全く同一のように扱えるか，というとそうではない． たとえば，配列aに別の配列のアドレスを代入することはできない．\nint a[] = {0, 1, 2}\nint *p = a;\nint b[] = {3, 4, 5};\np = b; // OK\na = b; // コンパイル時にエラー",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#演習",
    "href": "week06.html#演習",
    "title": "6  C言語の復習 5",
    "section": "6.6 演習",
    "text": "6.6 演習\n\n6.6.1 問題1\n要素数5のint型配列aを宣言し，中身を適当に定義せよ． 2種類の方法でaの要素を順番に出力するプログラムを作成せよ． ファイル名はq1.cとする．\n\na[i]のインデックスiをインクリメントするfor文\na[0]のアドレスを格納するポインタをインクリメントするfor文\n\n\n\n6.6.2 問題2\ndouble型配列の要素を逆順に並べ替えて返す関数invertを作成せよ．ただし，invertはポインタを引数とし，関数内でa[i]のように配列にインデックスでアクセスする書き方をしないものとする．\nvoid invert(double *a, int n){\n  // a[i]という書き方は使わない \n}\nファイル名はq2.cとする．",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#footnotes",
    "href": "week06.html#footnotes",
    "title": "6  C言語の復習 5",
    "section": "",
    "text": "64ビットマシンの場合．↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week07.html",
    "href": "week07.html",
    "title": "7  C言語の復習 6",
    "section": "",
    "text": "7.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#前回演習の解答",
    "href": "week07.html#前回演習の解答",
    "title": "7  C言語の復習 6",
    "section": "",
    "text": "ポインタ，ポインタと配列",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#本日のメニュー",
    "href": "week07.html#本日のメニュー",
    "title": "7  C言語の復習 6",
    "section": "7.2 本日のメニュー",
    "text": "7.2 本日のメニュー\n\n構造体\n共用体",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#構造体",
    "href": "week07.html#構造体",
    "title": "7  C言語の復習 6",
    "section": "7.3 構造体",
    "text": "7.3 構造体\n単一の数値や文字を保持するにはintやcharなど適当な型を設定した変数を用いて，一連のデータをまとめて扱うには，配列を使えばよかった． たとえば，あるクラスのテストの点数をまとめて管理するためにint型の配列を用いた． これに，テスト受験者の名前—つまり文字列データ—を紐づけて管理するにはどうすればよいか？\n構造体 (structure) を使うと，異なるデータ型をひとまとめにできる．構造体は，その内部に包含するデータの型を宣言し，あたかも新たなデータ型のように使うことができる． つぎの例は，ある人物に関するデータをまとめた構造体の宣言である．\nstruct person{\n  char name[128];  // 氏名\n  float height;    // 身長\n  float weight;    // 体重\n  int age;         // 年齢\n};\n行頭にstructを付けると，構造体の宣言となる．personはその構造体の名前（構造体タグ (structure tag)）である． タグに続くブロック{}の中に，この構造体が含むデータ（メンバ (member)）のデータ型とその名前が定義されている．\n\n\n\n\n\n\n構造体の宣言ブロック\n\n\n\n構造体宣言ブロックの末尾には;が必要である．関数の定義と異なることに注意．\n\n\nこれは構造体personという型の宣言であって，personという名前の変数が作られるわけではない． 実際にデータを格納するには，“person型”の変数を宣言して，値を代入する．\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; // 文字列をコピーする関数strcpyのために必要\nstruct person {\n  char name[128];  // 名前\n  float height;    // 身長\n  float weight;    // 体重\n  int age;         // 年齢\n};\n\nint main(void) {\n  struct person ohtani;\n  strcpy(ohtani.name, \"Shohei Ohtani\");\n  ohtani.height = 1.93;\n  ohtani.weight = 95.3;\n  ohtani.age = 30;\n  printf(\"%s (%d)\\n\", ohtani.name, ohtani.age);\n  printf(\"H: %4.3f m, W: %4.2f kg\\n\", ohtani.height, ohtani.weight);\n  return 0;\n}\n上のプログラムでは，3–8行目で構造体personを宣言している．この段階ではメモリ上にデータ領域は確保されていない．11行目で，“person型”の変数ohtaniが宣言され，ここでメモリ領域が確保される．大きさはchar[128] = 128バイト，float ✕ 2 = 8バイト，int ✕ 1 = 4バイトの計140バイトである 1． 12–15行目で，ohtaniのメンバに値が代入されており，そのデータは16, 17行目で参照されている．\n.は構造体のメンバにアクセスする演算子である．\n\n\n\n\n\n\nメンバにアクセスするための演算子\n\n\n\n構造体変数struc_nameのメンバmem_nameにアクセスするには，struc_name.mem_nameと書く．\n\n\n\n\n\n\n\n\nわざわざstrcpyを使う理由\n\n\n\nメンバnameは（ポインタ変数ではなく）配列として宣言されているため，\nohtani.name = &\"Shohei Ohtani\"; // エラー\nのように文字列リテラルのアドレスを代入して書き換えることはできない．また，既に宣言済みであって初期化ではないので\nohtani.name = \"Shohei Ohtani\"; // エラー\nもコンパイルエラーとなる．\n\n\n宣言と同時に初期化する場合には，配列の初期化と同様に{}の中に,区切りでメンバの値を指定する．上のプログラムのmain関数部分を以下のように書き換えた．\nint main(void) {\n  struct person ohtani = {\"Shohei Ohtani\", 1.93, 95.3, 30}; // 初期化\n  printf(\"%s (%d)\\n\", ohtani.name, ohtani.age);\n  printf(\"H: %4.3f m, W: %4.2f kg\\n\", ohtani.height, ohtani.weight);\n  return 0;\n}\n\n\n\n\n\n\nメンバの初期化\n\n\n\n配列の初期化と同様に，{}でメンバの一部のみ初期化した場合は，残りのメンバは0で初期化される．",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#構造体へのポインタ",
    "href": "week07.html#構造体へのポインタ",
    "title": "7  C言語の復習 6",
    "section": "7.4 構造体へのポインタ",
    "text": "7.4 構造体へのポインタ\n構造体は複数のデータ種類を一つの変数にまとめることができるので，関数の引数をコンパクトに，わかりやすく表現することができる．たとえば，人物に関するデータ処理を行う関数は，名前，身長，体重などのデータを個別に渡すよりも，人物データをひとつの変数にまとめた方がわかりやすいし，保守性が高い．\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nstruct person {\n  char name[128];  // 氏名\n  float height;    // 身長\n  float weight;    // 体重\n  int age;         // 年齢\n};\n\nvoid printBMI(struct person p) { // BMIを出力する関数\n  printf(\"%s's BMI: %f\\n\", p.name, p.weight / p.height / p.height);\n}\n\nint main(void) {\n  struct person ohtani = {\"Shohei Ohtani\", 1.93, 95.3, 30};\n  printBMI(ohtani);\n  return 0;\n}\n関数で構造体のデータを書き換えるには，構造体へのポインタを関数に渡して（参照渡し），呼び出し元における構造体を関数内で書き換える必要がある．\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nstruct person {\n  char name[128];  // 氏名\n  float height;    // 身長\n  float weight;    // 体重\n  int age;         // 年齢\n  double bmi;      // BMI\n};\n\nvoid calcBMI(struct person *p) { // BMIを書き込んで返す関数\n  double b = (*p).weight / (*p).height / (*p).height;\n  (*p).bmi = b;\n}\n\nint main(void) {\n  struct person ohtani = {\"Shohei Ohtani\", 1.93, 95.3, 30};\n  calcBMI(&ohtani);\n  printf(\"BMI: %lf\\n\", ohtani.bmi);\n}\nここで，(*p).bmiはp-&gt;bmiと書くこともできる．-&gt;をアロー演算子という． この表現を使うと，上の関数calcBMIはつぎのようにも書ける．\nvoid calcBMI(struct person *p) { // BMIを書き込んで返す関数\n  double b = p-&gt;weight / p-&gt;height / p-&gt;height;\n  p-&gt;bmi = b;\n}\n\n\n\n\n\n\nアロー演算子\n\n\n\n構造体へのポインタpのメンバmemを参照するには，(*p).memだけでなく\nstruct strTag *p; // 構造体 strTagへのポインタ\np-&gt;mem;           // = (*p).mem\nと書くこともできる．",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#構造体の受け渡し",
    "href": "week07.html#構造体の受け渡し",
    "title": "7  C言語の復習 6",
    "section": "7.5 構造体の受け渡し",
    "text": "7.5 構造体の受け渡し\n配列と異なり，構造体変数に別のオブジェクトを代入することができる．\nstruct person p1, ohtani = {\"Shohei Ohtani\", 1.93, 95.3, 30};\np1 = ohtani;  // 正常\nしたがって，構造体を返す関数を定義して，戻り値を呼び出し元で宣言した構造体変数に代入することもできる．つぎの例の関数createPersonは，必要な情報を受け取って，それらの情報を一つの構造体に加工して呼び出し元に返す関数である．\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nstruct person {\n  char name[128];  // 氏名\n  float height;    // 身長\n  float weight;    // 体重\n  int age;         // 年齢\n  float bmi;       // BMI\n};\n\nstruct person createPerson(char name[], float h, float w, int a) {\n  struct person p = {\"\", h, w, a};  // 構造体に詰めて返す\n  strcpy(p.name, name);\n  p.bmi = w / h / h;\n  return p;\n}\n\nint main(void) {\n  struct person p;\n  p = createPerson(\"Shohei Ohtani\", 1.93, 95.3, 30);\n  // ... 構造 p を使った処理を書く\n}\n構造体の配列も，データ型の配列と同様に定義できる．\nstruct person player[10];\nplayer[0] = createPerson(\"Shohei Ohtani\", 1.93, 95.3, 30);\nplayer[1] = createPerson(\"Aaron James Judge\", 2.01, 127.9, 33);\n// 後略",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#共用体",
    "href": "week07.html#共用体",
    "title": "7  C言語の復習 6",
    "section": "7.6 共用体",
    "text": "7.6 共用体\n構造体は型の異なるデータをまとめて管理できるが，メンバを増やすと使用するメモリ領域が大きくなる．複数の型のデータを格納するが，同時に保持するのはひとつのメンバだけという場合には，共用体 (union) として宣言することでメモリ領域を節約できる．\nたとえば，文字，整数，浮動小数点数のいずれかが入るデータ型keywordを定義したいとする．char, int, doubleの3種類をメンバとして持つ構造体は，\nstruct keyword{\n  char c;   // 1バイト\n  int i;    // 4バイト\n  double d; // 8バイト\n};\nとなり13バイト以上（データの切れ目を調整するパディングによって16バイト）が必要である．\nしかし，メンバのうち複数を同時に保持することが無いのであれば，一番大きなdoubleに合わせてメモリ領域を確保しておき（つまり8バイト分），実際には格納しているデータ型に応じて読み出す領域を決めてあげればメモリを節約できる．これは共用体で実現できる．\nunion ukeyword{\n  char c;   // 1バイト\n  int i;    // 4バイト\n  double d; // 8バイト\n}; // 最大のdoubleに合わせて8バイト（宣言時に）確保される\n共用体オブジェクトの参照には構造体と同じく.演算子を使う．",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#演習",
    "href": "week07.html#演習",
    "title": "7  C言語の復習 6",
    "section": "7.7 演習",
    "text": "7.7 演習\n\n7.7.1 問題1\n書籍の情報を保持する構造体を定義して，手元にある3冊の本の情報を構造体配列に保存せよ． 書籍1冊の情報には，以下を含むこと．\n\n書名\n著者名\n価格\nISBN\n発行年\n\nこの構造体を用いて，以下の動作を実現せよ．\n\n本1冊の情報を出力する関数printBookInfoを作成し，それを用いて3冊全ての情報を出力する\n発行年が古い順に配列を並び替える関数sortBookByYearを作成し，並び替えを実行する\n再び3冊全ての情報を出力し，ソートが完了していることを確認する\n\nプログラム名はq1.cとする．\n\n\n7.7.2 問題2\n以下の情報を含む構造体personを定義せよ．\n\n名前\n\n文字列\n\n性別\n\n‘M’または’F’\n\n父親\n\nperson型へのポインタ\n\n母親\n\nperson型へのポインタ\n\n\n構造体personを用いて，サザエさん一家（下表のとおりとする）の人物情報を構造体に格納せよ．格納したデータのうちFuguta Taraoを表すデータから出発し，母系の系譜を順に出力せよ．ファイル名はq2.cとする．\n父母が「不明」の場合は，NULLに設定せよ．NULLは何も指さないことを意味する特殊なポインタである．たとえば，構造体変数psn[0]のメンバfatherに何も指さないポインタを代入するには，以下のように書く．\npsn[0].father = NULL;\n\n\n\n名前\n性別\n父\n母\n\n\n\n\nIsono Namihei\nM\n不明\n不明\n\n\nIsono Fune\nF\n不明\n不明\n\n\nFuguta Masuo\nM\n不明\n不明\n\n\nFuguta Sazae\nF\n-&gt; Isono Namihei\n-&gt; Isono Fune\n\n\nIsono Katsuo\nM\n-&gt; Isono Namihei\n-&gt; Isono Fune\n\n\nIsono Wakame\nF\n-&gt; Isono Namihei\n-&gt; Isono Fune\n\n\nFuguta Tarao\nM\n-&gt; Fuguta Masuo\n-&gt; Fuguta Sazae",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#footnotes",
    "href": "week07.html#footnotes",
    "title": "7  C言語の復習 6",
    "section": "",
    "text": "確かめるにはprintf(\"%lu\\n\", sizeof(struct person))としてみよう．メンバの型と順番によってはバイト数の切れ目を調整するパディングが発生し，単純なメンバのデータサイズの和より大きくなることがある．↩︎",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week08.html",
    "href": "week08.html",
    "title": "8  再帰的アルゴリズム",
    "section": "",
    "text": "8.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>再帰的アルゴリズム</span>"
    ]
  },
  {
    "objectID": "week08.html#前回演習の解答",
    "href": "week08.html#前回演習の解答",
    "title": "8  再帰的アルゴリズム",
    "section": "",
    "text": "構造体",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>再帰的アルゴリズム</span>"
    ]
  },
  {
    "objectID": "week08.html#本日のメニュー",
    "href": "week08.html#本日のメニュー",
    "title": "8  再帰的アルゴリズム",
    "section": "8.2 本日のメニュー",
    "text": "8.2 本日のメニュー\n\nアルゴリズムと計算量\n再帰的アルゴリズム",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>再帰的アルゴリズム</span>"
    ]
  },
  {
    "objectID": "week08.html#アルゴリズムとは何か",
    "href": "week08.html#アルゴリズムとは何か",
    "title": "8  再帰的アルゴリズム",
    "section": "8.3 アルゴリズムとは何か",
    "text": "8.3 アルゴリズムとは何か\nアルゴリズムとは，問題解決のための手続きを明確に定めたものである． たとえば，前回演習の解答で示したバブルソートは，「与えられた数列を昇順に並び替えた列を求める問題」に対するアルゴリズムのひとつである．\n\n\n\n\n\n\nアルゴリズムとは\n\n\n\nある種の問題に対し，有限回の操作により，解がある場合にはその解を，解がない場合にはそのことを示す手順．\n\n\n\n\n\nアルゴリズムたいそうはアルゴリズムではない (x.com/itsukokoyamada より)\n\n\n最大公約数を求めるユークリッドの互除法は，アルゴリズムの説明によく用いられる: 自然数\\(a\\)と\\(b\\)について，\\(a = qb + r\\)のように\\(a\\)を\\(b\\)で割った剰余\\(r\\)を求めると，\\(a, b\\)の最大公約数は\\(b, r\\)の最大公約数に等しい． これを用いて，\\(a, b\\)を\\(r=0\\)になるまで順次小さくしていく方法である．\nたとえば，\\(1071\\)と\\(1029\\)の最大公約数は，以下の手順で求められる．\n\n\\(1071\\)を\\(1029\\)で割った余りを求める: \\(42\\)\n\\(1029\\)を\\(42\\)で割った余りを求める: \\(21\\)\n\\(42\\)を\\(21\\)で割った余りを求める: \\(0\\)\n剰余が\\(0\\)となったので停止．\\(21\\)が最大公約数\n\nこの手順を一般の\\(a\\), \\(b\\)に適用できるように書き下す．\n\n\n\n\n\n\nユークリッドの互除法\n\n\n\n自然数\\(a\\), \\(b\\)を与える．\n\n\\(a&lt;b\\)ならば\\(a\\)と\\(b\\)を入れ替える\n\\(a\\)を\\(b\\)で割った余りを\\(r\\)とする\n\\(r=0\\)ならば\\(b\\)を出力して終了; \\(r \\neq 0\\)ならば\\(a\\leftarrow b\\), \\(b\\leftarrow r\\)1\n手順2に戻る\n\n\n\nアルゴリズムを図的に表記する方法として，フローチャートがよく使われる．ユークリッドの互除法をフローチャートで表すと下記のとおり．\n\n\n\n\n\nflowchart TD\n\na1([開始])--&gt;a2{ a &lt; b ?}\na2--&gt;|Yes|a3[aとbを入れ替え]\na3--&gt;a4[\"r ← aをbで割った余り\"]\na2--&gt;|No|a4\na4--&gt;a5{r = 0 ?}\na5--&gt;|Yes|a6[\"最大公約数 ← b\"]\na5--&gt;|No|a7[\"a ← b \nb ← r\"]\na7--&gt;a4\na6--&gt;a8([終了])\n\n\n\n\n\n\nアルゴリズムをプログラミング言語を用いて実装することは，プログラミングの主な目的のひとつである．\n\n\n\n\n\n\nユークリッドの互除法をC言語で実装してみよう\n\n\n\n\n\nフローチャートをもとに実装した例は下記の通り．\n#include &lt;stdio.h&gt;\nint main(void) {\n  int a, b, r;\n  printf(\"自然数a, bを入力: \");\n  scanf(\"%d%d\", &a, &b);\n  // ここからユークリッドの互除法\n  if (a &lt; b) {\n    int tmp = a;\n    a = b;\n    b = a;\n  }\n\n  while (1) {\n    r = a % b;\n    if (r == 0) {\n      printf(\"最大公約数は%d\\n\", b);\n      return 0;\n    }\n    a = b;\n    b = r;\n  }\n}",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>再帰的アルゴリズム</span>"
    ]
  },
  {
    "objectID": "week08.html#アルゴリズムの改良",
    "href": "week08.html#アルゴリズムの改良",
    "title": "8  再帰的アルゴリズム",
    "section": "8.4 アルゴリズムの改良",
    "text": "8.4 アルゴリズムの改良\nアルゴリズムを設計する上で，正しいこと—つまり有限回で停止して，解が得られる（または解が無いことを確認できる）—は大前提として（数学的に確認する必要がある），計算量と実装のしやすさは重要である．\n与えられた自然数\\(N\\)について，素数か否かを判定する問題に対するアルゴリズムを考えよう． 素数とは，\\(2\\)以上の整数であって，\\(1\\)とその数自身でしか割り切れない数のことであるから，\\(2\\)以上\\(N-1\\)以下の数で\\(N\\)を割った剰余を調べ，ひとつでも0であれば素数ではない（合成数），そうでなければ素数である．\nこれを実装してみよう．\n#include &lt;stdio.h&gt;\n#define N 198491317 // 素数か否かを判定したい数\nint main(void) {\n  for (unsigned long i = 2; i &lt;= N - 1; i++) {\n    if (N % i == 0) {\n      printf(\"%dは合成数\\n\", N);\n      return 0;\n    }\n  }\n  printf(\"%dは素数\\n\", N);\n  return 0;\n}\nこの方法の最悪ケースでは，剰余計算\\(N-2\\)回，比較\\(N-2\\)回が行われ，時間計算量は\\(O(N)\\)である． 通常は\\(N\\)をビット列で表現した入力データサイズ\\(n = \\lceil\\log_2 N\\rceil\\)に対して計算時間を考えるので，\\(O(2^n)\\)であり指数時間のアルゴリズムである．\nもう少し計算量を減らせないだろうか？\n\n8.4.1 改良1\n\\(N = \\sqrt{N} \\sqrt{N}\\)なので，もし\\(N\\)が2つの自然数の積で書けるなら，どちらか一方は\\(\\sqrt{N}\\)以下である．したがって，試し割りをする範囲は\\(\\sqrt{N}\\)以下でよい．これで探索範囲を減らすことができる． 最悪ケースの時間計算量は\\(O(\\sqrt{N}) = O(2^{n/2})\\)であり，依然として指数時間であるが，前述の方法よりは減った．\n\n\n8.4.2 改良2\nさらに，\\(2\\)を除く偶数で割り切れる場合は\\(2\\)でも割り切れるはずである．したがって，\\(2\\)より大きい\\(i\\)については奇数のみチェックすればよい． これを一般化して，既知の素数の倍数は試し割りの数から抜いてよい． たとえば\\(2, 3\\)を既知の素数として採用すると，これらの倍数を除いた数は，\\(6k\\pm 1\\) (\\(k\\in\\mathbb{N}\\)) と表せる．したがって，試し割りの除数を\\(5, 7\\)から始めて\\(6\\)ずつ増加させていけばよい． 既知素数の組を増やした場合にも，除数の候補に一定のパターンが現れることが知られている2．\n#include &lt;stdio.h&gt;\n#define N 198491317\nint main(void) {\n  if (N % 2 == 0 || N % 3 == 0) {\n    printf(\"%dは合成数\\n\", N);\n    return 0;\n  }\n\n  for (unsigned long i = 5; i * i &lt;= N; i += 6) {\n    if (N % i == 0 || N % (i + 2) == 0) {\n      printf(\"%dは合成数\\n\", N);\n      return 0;\n    }\n  }\n  printf(\"%dは素数\\n\", N);\n  return 0;\n}\n計算量は\\(O(\\sqrt{N})\\)で改良1と同じだが，係数部分が約\\(1/3\\)に減少して計算量を削減できている． 素数判定問題に対する多項式時間のアルゴリズムとして，2002年に\\(O(\\log n)\\)で判定可能なAKS法が発表された．",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>再帰的アルゴリズム</span>"
    ]
  },
  {
    "objectID": "week08.html#再帰的アルゴリズム",
    "href": "week08.html#再帰的アルゴリズム",
    "title": "8  再帰的アルゴリズム",
    "section": "8.5 再帰的アルゴリズム",
    "text": "8.5 再帰的アルゴリズム\n規模の大きい問題に対して，同じ種類の小規模な問題に分割して解く方法がある． たとえば，配列から最大値を見つける問題に対して，配列を2分割して検索対象を小さくし，小さな配列の最大値同士を比較することで元の配列の最大値を求めることができる． 再帰はそのようなアルゴリズムを実装する方法の一種で，再帰的アルゴリズムは自分自身を用いて定義されるアルゴリズムのことである．\nよくある例として，階乗の計算がある．つぎの関数は，自然数\\(n\\)を引数として，その階乗\\(n!\\)を計算して返す関数である．\nint factorial(int n) {\n  if (n &gt; 0) {\n    return n * factorial(n - 1);\n  } else {\n    return 1;\n  }\n}\n3行目をみると，関数factorialの中でfactorial自身が呼び出されている． \\(n = 3\\)の場合の実行を追ってみると，2行目で\\(3 &gt; 0\\)は真なので，戻り値は3 * factorial(2)である．factorial(2)の計算でfactorialが呼び出され，2行目で\\(2 &gt; 0\\)は再び真となり，2 * factorial(1)を返す．これを繰り返してfactorial(0)のとき，\\(1\\)が返され，呼び出し元に戻る過程で\\(3(2(1\\cdot 1)) = 3!\\)の計算が行われる．\n同様の計算は，for文やwhile文でも実装できる． 再帰を用いるメリットは，ある種の問題に対して意味が明確で簡潔となることである． とくに数学的帰納法や本節冒頭で述べた分割統治法と相性がよい．\n再帰的アルゴリズムを実装する場合は，終了条件にたどり着けるかどうかを確認しよう． 階乗の例では，呼び出しごとにnが減少してn &gt; 0が偽，つまりn == 0のときは1が返るので，無限に呼び出しが続くことはない． 実装してみてうまく動かない場合は，具体的に値を代入して，紙上で動作を再現してみるとよい．",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>再帰的アルゴリズム</span>"
    ]
  },
  {
    "objectID": "week08.html#演習",
    "href": "week08.html#演習",
    "title": "8  再帰的アルゴリズム",
    "section": "8.6 演習",
    "text": "8.6 演習\n\n8.6.1 問題1\n再帰的アルゴリズムによりユークリッドの互除法を用いて最大公約数を求めるプログラムを作成せよ．ファイル名をrec_euc.cとする．\n\n\n8.6.2 問題2\nフィボナッチ数列 (Fibonacci sequence) \\(\\{F_n\\}\\)とは，\\(F_0 = 0,\\ F_1 = 1\\)として，\\(F_n\\)を直前の2つの項の和で定める数列である． \\(n = 2,\\ 3,\\ \\dots,\\ 47\\)に対して，再帰的アルゴリズムで\\(F_n/F_{n-1}\\)を求めるプログラムを作成せよ． ファイル名をfibo.cとする．",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>再帰的アルゴリズム</span>"
    ]
  },
  {
    "objectID": "week08.html#footnotes",
    "href": "week08.html#footnotes",
    "title": "8  再帰的アルゴリズム",
    "section": "",
    "text": "\\(x \\leftarrow y\\)は，\\(x\\)に\\(y\\)を代入することを意味する．↩︎\nWheel factorization↩︎",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>再帰的アルゴリズム</span>"
    ]
  },
  {
    "objectID": "week09.html",
    "href": "week09.html",
    "title": "9  リスト構造",
    "section": "",
    "text": "9.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>リスト構造</span>"
    ]
  },
  {
    "objectID": "week09.html#前回演習の解答",
    "href": "week09.html#前回演習の解答",
    "title": "9  リスト構造",
    "section": "",
    "text": "再帰アルゴリズム",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>リスト構造</span>"
    ]
  },
  {
    "objectID": "week09.html#本日のメニュー",
    "href": "week09.html#本日のメニュー",
    "title": "9  リスト構造",
    "section": "9.2 本日のメニュー",
    "text": "9.2 本日のメニュー\n\n\nリスト構造",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>リスト構造</span>"
    ]
  },
  {
    "objectID": "week09.html#リストの基本",
    "href": "week09.html#リストの基本",
    "title": "9  リスト構造",
    "section": "9.3 リストの基本",
    "text": "9.3 リストの基本\n順序をもつ一連のデータを保存したいとき，配列を用いる方法は既に学習した．しかし，配列では実現が難しい操作がある:\n\n配列の途中にデータを挿入する\n順序を入れ替える\n要素を取り出して配列から削除する\n\nこれらの操作は単独の配列では実装が難しい． データ保存用と，順序情報の保存用の2本の配列を用いることで実現は可能であるが，未使用領域の管理が煩雑で非効率的という欠点がある．\n\n\n\n配列に対する要素の挿入，順序交換，削除のイメージ図\n\n\nそこで，データに加えて前後のデータの保存場所をひとまとめにしておき，順にデータをたどることができるリスト構造を用いる． C言語でこれを実現するには，データと前後のデータへのポインタをメンバにもつ構造体を定義するとよい．\nまずは，一方向にのみデータをたどることができる単方向リストを考えよう． 学生のテストの点数を保存するリストを作る．学生の名前と点数，次の学生のデータへのポインタをメンバにもつ構造体を定義しよう．\nstruct student {\n  char name[64];        // 学生の名前\n  int score;            // テストの点数\n  struct student *next; // 次の学生データへのポインタ\n};\ntypedef struct student Student;\nこれからstruct studentをたくさん使うので，いちいち書くのが面倒である．そこで，6行目のtypedef宣言で，struct studentを新しくStudentという名前の型として使用することを宣言している．型名の先頭を大文字にするのは，独自に定義した型であることをわかりやすくするための慣例であって文法上必須ではない．\n\n\n\n\n\n\n構造体とtypedef宣言をまとめて書く\n\n\n\n構造体の宣言とtypedefをまとめて書くこともできる．\ntypedef struct student {\n  char name[64];\n  int score;\n  struct student *next;\n} Student;",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>リスト構造</span>"
    ]
  },
  {
    "objectID": "week09.html#データの追加",
    "href": "week09.html#データの追加",
    "title": "9  リスト構造",
    "section": "9.4 データの追加",
    "text": "9.4 データの追加\n早速3人分のデータを保存してみよう．\n\n\n\n名前\n点数\n\n\n\n\nAlice\n100\n\n\nBob\n62\n\n\nDave\n80\n\n\n\n構造体の要素を\nStudent alice = {\"Alice\", 100, NULL};\nのように一つずつ宣言してポインタでつないでもよいが，リストの先頭からたどることができれば目的は達成なので，個別に変数名を付ける必要はない． そこで，malloc関数を使ってメモリ領域を確保し，その領域へのポインタをリストの前のデータに保存するようにする．\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt; // mallocのために必要\n#include &lt;string.h&gt; // strcpyのために必要\n\n// Student の定義は省略\n\nint main(void) {\n  Student *head = NULL;  // リストの先頭へのポインタ．とりあえず空で宣言\n  // 最初の要素を定義\n  head = (Student *)malloc(sizeof(Student)); \n  strcpy(head-&gt;name, \"Alice\");\n  head-&gt;score = 100;\n\n  // 2番目の要素を定義\n  head-&gt;next = (Student *)malloc(sizeof(Student));\n  strcpy(head-&gt;next-&gt;name, \"Bob\");\n  head-&gt;next-&gt;score = 62;\n  // ...\n  // 後略\n}\n10行目のmalloc(sizeof(Student))はStudent型の分だけメモリ領域を確保する動作を意味する．mallocの戻り値はvoid*型なので，それをStudent*にキャストするために(Student *)が付いている． なお，キャストはしなくても動作する．\n11, 12行目の-&gt;は構造体へのポインタからメンバにアクセスするための演算子であった（cf. 第7週）． つまり，11, 12行目でリストの最初の要素にAliceのデータを保存できている．\n2番目のデータは，15行目でメモリ領域が確保され，16, 17行目でデータが格納されている．\nこれを続けていくと，-&gt;がとんでもない長さになりそうである．そこで，リストに要素を追加する関数add_studentを定義する．\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n// Student の定義は省略\n\n// リストの末尾に新たなStudent要素を追加して返す関数\nStudent *add_student(Student *head, char name[], int score) {\n  Student *new = (Student *)malloc(sizeof(Student));  // 新規要素のメモリ確保\n  strcpy(new-&gt;name, name);\n  new-&gt;score = score;\n  new-&gt;next = NULL;  // 末尾に追加するので次のデータはNULL\n\n  if (head == NULL) {          // 既存のリストが空なら\n    return new;                // 新規要素を先頭として返す\n  } else {                     // 既存リストが空でない場合\n    Student *p = head;         // リストをたどるためのポインタ\n    while (p-&gt;next != NULL) {  // リストの先頭から末尾までたどる\n      p = p-&gt;next;\n    }\n    p-&gt;next = new;  // 末尾に新規要素を追加\n    return head;\n  }\n}\n\n// リスト要素のメモリをすべて解放する関数\nvoid free_list(Student *head) {\n  Student *p = head;  // リストをたどる作業用ポインタ\n  while (p != NULL) {\n    Student *nx = p-&gt;next;  // 次の要素へのポインタを別に保存しておく\n    free(p);                // メモリを解法\n    p = nx;                 // 次の要素へ進む\n  }\n}\n\nint main(void) {\n  Student *head = NULL;  // リストの先頭へのポインタ．とりあえず空で宣言\n  head = add_student(head, \"Alice\", 100);\n  head = add_student(head, \"Bob\", 62);\n  head = add_student(head, \"Dave\", 80);\n\n  free_list(head);\n  return 0;\n}\n8–24行目の関数add_studentは，リストの先頭へのポインタと，追加する新規要素のデータを引数にして，末尾にその要素を追加したリストの先頭ポインタを返す関数である． ここで，戻り値としてリスト先頭へのポインタheadを返すのは，先頭のアドレスがadd_student内で変更された場合に，そのアドレスを呼び出し元に返す必要があるため． 9–12行目では追加する要素の実体を作成している． 14–23行目は，追加した要素を渡されたリストの末尾に追加する作業を行っている．\nこの関数を使うと，3人分のデータをもつリストの作成は37–40行目のようにコンパクトに書くことができる．\n順番が前後したが，27–34行目で定義されるfree_list関数は，リストの要素を定義するために確保されたメモリ領域を解放する関数である．C言語では，プログラム実行中にmallocで動的に確保されたメモリ領域は自動で解放されず，キープされたままになる（OSがどうにかする場合もある）．これが重なると，メモリ領域を使用し尽くしてしまうので，mallocで確保した領域は，不要になった段階でfreeで解放する．\n\n\n\n\n\n\nリストの中身を出力してみよう\n\n\n\n\n\n作成したリストを出力する関数を定義して，内容を確認してみよう．\n// 渡されたStudentリストの中身を末尾まで出力する関数\nvoid print_list(Student *head) {\n  Student *current = head;\n  printf(\"リストの内容:\\n\");\n  while (current != NULL) {\n    printf(\"%s %d点\\n -&gt; \", current-&gt;name, current-&gt;score);\n    current = current-&gt;next;\n  }\n  printf(\"NULL\\n\");\n}\nint main(void){\n    // リストの定義は省略\n    print_list(head); // リストの中身を出力\n    free_list(head);\n    return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>リスト構造</span>"
    ]
  },
  {
    "objectID": "week09.html#データの削除",
    "href": "week09.html#データの削除",
    "title": "9  リスト構造",
    "section": "9.5 データの削除",
    "text": "9.5 データの削除\nリストからデータを削除する操作を実装しよう． 上記で作成した3人のテスト点数データから，名前をキーとして要素を指定し，一致するデータを削除する．削除後もリスト構造が保持されるようにしなければならない．つまり，削除する前の要素のnextポインタを，削除する次の要素へ付け替える操作が必要である． これを実現するために，ポインタ変数として，削除対象の要素を指すものとその前の要素を指すものの2つを用意する． リストの先頭が削除対象となる場合には，リストの先頭を表すポインタを書き換えるため，例外処理が必要である．\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\ntypedef struct student Student; // 略\n// リストの末尾に新たなStudent要素を追加して返す関数\nStudent *add_student(Student *head, char name[], int score); // 略\n// リスト要素のメモリをすべて解放する関数\nvoid free_list(Student *head); // 略\n// リストの中身を出力する関数\nvoid print_list(Student *head); // 略\n\n// 名前で指定した学生のデータを削除する関数\nStudent *delete_student(Student *head, char target_name[]) {\n  Student *prev = NULL;\n  Student *current = head;\n  while (current != NULL) {  // リスト末尾まで順に調べるループ\n    if (strcmp(current-&gt;name, target_name) == 0) {  // 削除対象が見つかった\n      if (prev == NULL) {            // 先頭要素を削除する場合\n        head = current-&gt;next;        // head = 2番目要素へのポインタ\n      } else {                       // 2番目以降の要素を削除する場合\n        prev-&gt;next = current-&gt;next;  // currentを抜いてリストをつなげる\n      }\n      free(current);  // 削除対象のメモリ解放\n    }\n    prev = current;           // 次の要素へ\n    current = current-&gt;next;  // 次の要素へ\n  }\n  return head;\n}\n\nint main(void) {\n  Student *head = NULL;  // リストの先頭へのポインタ．とりあえず空で宣言\n  head = add_student(head, \"Alice\", 100);\n  head = add_student(head, \"Bob\", 62);\n  head = add_student(head, \"Dave\", 80);\n\n  printf(\"----削除前----\\n\");\n  print_list(head);\n  head = delete_student(head, \"Bob\");\n  printf(\"----削除後----\\n\");\n  print_list(head);\n\n  free_list(head);\n  return 0;\n}\n13–29行目が削除を行う関数である．17行目では，文字列の比較にstrcmp関数を使っている．単純に==で文字列配列の比較ができないことは，第5週で学んだ．",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>リスト構造</span>"
    ]
  },
  {
    "objectID": "week09.html#双方向リスト",
    "href": "week09.html#双方向リスト",
    "title": "9  リスト構造",
    "section": "9.6 双方向リスト",
    "text": "9.6 双方向リスト\n要素を順方向にも逆方向にもたどれる双方向リストを実現するには，リストを構成する構造体に前後両方のデータへのポインタを含める． 構造体の宣言を以下のように修正すればよい．\nstruct student {\n  char name[64];\n  int score;\n  struct student *prev; // 前のデータへのポインタ\n  struct student *next;\n};\ntypedef struct student Student;\n\n\n\n\n\n\nリストを逆順にたどって出力する関数を作成してみよう\n\n\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nstruct student {\n  char name[64];\n  int score;\n  struct student *prev;\n  struct student *next;\n};\ntypedef struct student Student;\n\nStudent *add_student(Student *head, char name[], int score) {\n  Student *new = (Student *)malloc(sizeof(Student));  // 新規要素のメモリ確保\n  strcpy(new-&gt;name, name);\n  new-&gt;score = score;\n  new-&gt;prev = NULL;  // 追加要素の前は未定なのでとりあえずNULL\n  new-&gt;next = NULL;  // 末尾に追加するので次のデータはNULL\n\n  if (head == NULL) {          // 既存のリストが空なら\n    return new;                // 新規要素を先頭として返す\n  } else {                     // 既存リストが空でない場合\n    Student *p = head;         // 作業用ポインタ\n    while (p-&gt;next != NULL) {  // リストの先頭から末尾までたどる\n      p = p-&gt;next;\n    }\n    p-&gt;next = new;  // 末尾に新規要素を追加\n    new-&gt;prev = p;  // 追加した要素の前の要素\n    return head;\n  }\n}\n// リストの先頭から出力する関数\nvoid print_list(Student *head) {\n  Student *current = head;\n  printf(\"リストの内容: \");\n  while (current != NULL) {\n    printf(\"%d -&gt; \", current-&gt;score);\n    current = current-&gt;next;\n  }\n  printf(\"NULL\\n\");\n}\n// リストの末尾から出力する関数\nvoid print_list_reverse(Student *head) {\n  Student *current = head;\n  printf(\"リストの内容: \");\n  while (current-&gt;next != NULL) {\n    current = current-&gt;next;\n  }\n  while (current != NULL) {\n    printf(\"%s %d点 &lt;- \", current-&gt;name, current-&gt;score);\n    current = current-&gt;prev;\n  }\n  printf(\"NULL\\n\");\n}\n// リスト要素のメモリをすべて解放する関数\nvoid free_list(Student *head) {\n  Student *p = head;  // リストをたどる作業用ポインタ\n  while (p != NULL) {\n    Student *nx = p-&gt;next;  // 次の要素へのポインタを別に保存しておく\n    free(p);                // メモリを解法\n    p = nx;                 // 次の要素へ進む\n  }\n}\nint main(void) {\n  Student *head = NULL;  // リストの先頭へのポインタ．とりあえず空で宣言\n  head = add_student(head, \"Alice\", 100);\n  head = add_student(head, \"Bob\", 62);\n  head = add_student(head, \"Dave\", 80);\n  print_list(head);\n  print_list_reverse(head);\n  free_list(head);\n  return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>リスト構造</span>"
    ]
  },
  {
    "objectID": "week09.html#演習",
    "href": "week09.html#演習",
    "title": "9  リスト構造",
    "section": "9.7 演習",
    "text": "9.7 演習\n\n9.7.1 問題1\nテストの点数データの単方向について，リストの指定した番号に新規データを挿入する関数を作成せよ．指定した番号がリストの長さを超える場合は，リストの末尾に追加するとする． 挿入関数の戻り値と引数の型は以下のとおりとする．\n// 渡したリストのk番目に新規データを挿入する関数\nStudent *insert_student(Student *head, int k, char name[], int score)\n作成した関数を用いて，データ（Carol, 55点）を3番目（Bobの後）に挿入せよ． また，データ(Edward, 99点)を100番目を指定して（結果的にリストの末尾に）挿入せよ． ファイル名をins_list1.cとする．\n\n\n9.7.2 問題2\n問題1と同様の仕様で双方向リストに対応した関数を作成せよ． 同じくデータ（Carol, 55点）を3番目に，データ(Edward, 99点)を100番目を指定して（結果的にリストの末尾に）挿入し，リストの中身を順方向と逆方向に出力して編集結果を確認せよ． ファイル名をins_list2.cとする．",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>リスト構造</span>"
    ]
  },
  {
    "objectID": "week10.html",
    "href": "week10.html",
    "title": "10  演習",
    "section": "",
    "text": "10.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>演習</span>"
    ]
  },
  {
    "objectID": "week10.html#前回演習の解答",
    "href": "week10.html#前回演習の解答",
    "title": "10  演習",
    "section": "",
    "text": "リスト構造",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>演習</span>"
    ]
  },
  {
    "objectID": "week10.html#本日のメニュー",
    "href": "week10.html#本日のメニュー",
    "title": "10  演習",
    "section": "10.2 本日のメニュー",
    "text": "10.2 本日のメニュー\n\n演習（C言語の基本の確認）\nレポート課題2の説明",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>演習</span>"
    ]
  },
  {
    "objectID": "week11.html",
    "href": "week11.html",
    "title": "11  データ構造 1",
    "section": "",
    "text": "11.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データ構造 1</span>"
    ]
  },
  {
    "objectID": "week11.html#前回演習の解答",
    "href": "week11.html#前回演習の解答",
    "title": "11  データ構造 1",
    "section": "",
    "text": "授業内小テストの採点結果\nレポート課題2の解説",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データ構造 1</span>"
    ]
  },
  {
    "objectID": "week11.html#本日のメニュー",
    "href": "week11.html#本日のメニュー",
    "title": "11  データ構造 1",
    "section": "11.2 本日のメニュー",
    "text": "11.2 本日のメニュー\n\nスタック\nキュー",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データ構造 1</span>"
    ]
  },
  {
    "objectID": "week11.html#スタックの基本",
    "href": "week11.html#スタックの基本",
    "title": "11  データ構造 1",
    "section": "11.3 スタックの基本",
    "text": "11.3 スタックの基本\nデータを保存–読み出す構造のひとつで，最後に保存したものを最初にとりだす方式（Last-In First-Out; LIFO）のものをスタック（stack）と呼ぶ． 関数の呼び出し関係の表現（コールスタック）や木構造データの深さ優先探索で用いられる．データを縦に積み重ね，データを追加するときは一番上に追加し，取り出すときは一番上からとるイメージを持つと理解しやすい．\n\n\n\nスタックの概念図．赤矢印は操作を，黒矢印は後の実装例におけるポインタを表す\n\n\nスタックに対する基本操作は以下のとおり：\n\nプッシュ（push）\n\nデータをスタックに追加する\n\nポップ（pop）\n\nスタックからデータを取り出して，スタックから削除する\n\nピーク（peek）\n\nスタックの先頭要素（一番上のデータ）を確認し，削除しない\n\n\nこのほか，スタックに要素があるか否かの確認もよく使う．",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データ構造 1</span>"
    ]
  },
  {
    "objectID": "week11.html#スタックの実装",
    "href": "week11.html#スタックの実装",
    "title": "11  データ構造 1",
    "section": "11.4 スタックの実装",
    "text": "11.4 スタックの実装\nスタックを実現するには，配列とデータの先頭を表すポインタを使う場合と，リスト構造を使う場合の主に2種類の実装がある． 以下ではリスト構造を使った実装例を見てみよう．\n\n11.4.1 リスト構造によるスタックの実装\nスタックに保存するデータ要素ひとつを構造体で定義する．構造体には，データ（ここではintデータひとつ）と，次の要素へのポインタを含み，単方向リスト構造を構成できるようにする．\n// スタックの要素ひとつを表す構造体\ntypedef struct node {\n  int data;\n  struct node *next;\n} Node;\nこの後，スタックに対する操作を色々実装するので，1本のスタックそのものも型を定義しておく．実体としては，スタック先頭を表すNode構造体へのポインタである．\n// intデータを保持するスタック\ntypedef struct stack {\n  Node *top; // 先頭データへのポインタ\n} Stack;\n新しいスタックを作成したときには，何も要素が入っていない．そこで，先頭要素へのポインタを初期化する関数を作っておく．\n// スタックの初期化\nvoid initStack(Stack *s) {\n  s-&gt;top = NULL;\n}\n\n\n11.4.2 プッシュ\nプッシュ操作は，メモリ領域を確保して，指定されたデータを保持するNodeをスタックの先頭に付ける．\nint push(Stack *s, int newdata) {\n  Node *newNode = (Node *)malloc(sizeof(Node));\n  if (newNode == NULL) {  // メモリ領域の確保に失敗したとき\n    return -1;            // 異常値 -1 を呼び出し元に返す\n  }\n\n  newNode-&gt;data = newdata;\n  newNode-&gt;next = s-&gt;top;\n  s-&gt;top = newNode;\n  return 0;\n}\nここで，3–5行目のif文は例外処理である． malloc関数は，メモリ確保に失敗した場合にNULLを返す．メモリが確保できなかった場合には，異常を表す-1を呼び出し元にreturnして終了する．\n正常系の処理はifブロックの後にある．新しいデータであるnewNode（の指すNode）はスタックの先頭になるので，newNodeの次のノードは従来の先頭であるs-&gt;top，新たなスタックの先頭がnewNodeである．\n\n\n11.4.3 ポップ\nポップ操作の実装例は以下のとおり．\nint isEmpty(Stack *s) {\n  return s-&gt;top == NULL;\n}\n\nint pop(Stack *s, int *poppedData) {\n  if (isEmpty(s)) {\n    return -1; // スタックが空のとき異常値 -1 を呼び出し元に返す\n  }\n\n  Node *poppedNode = s-&gt;top;\n  *poppedData = poppedNode-&gt;data;\n  s-&gt;top = poppedNode-&gt;next;\n  free(poppedNode);\n  return 0;\n}\nポップ操作を行うスタックが空のとき，異常値を表す-1を呼び出し元に返す． これにはスタックが空か否かを判定する関数isEmptyを別途作成して利用する．\nポップによって先頭ノードpoppedNodeはスタックから削除され，次のノードpoppedNode-&gt;nextが新たなスタックの先頭となる．\n関数popの戻り値は正常/異常を表すために使うので，読み出したデータは引数として受け取ったポインタに詰めて返す．\n\n\n11.4.4 ピーク\nピーク操作でも，ポップと同様にスタックが空のときは例外処理を行う． ポップと異なり，ピーク操作ではスタックの先頭ノードのデータを返すが，スタックから削除しない．\nint peek(Stack *s, int *topData) {\n  if (isEmpty(s)) {\n    return -1; // スタックが空のとき異常値 -1 を呼び出し元に返す\n  }\n\n  *topData = s-&gt;top-&gt;data;\n  return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データ構造 1</span>"
    ]
  },
  {
    "objectID": "week11.html#スタックを操作するプログラム例",
    "href": "week11.html#スタックを操作するプログラム例",
    "title": "11  データ構造 1",
    "section": "11.5 スタックを操作するプログラム例",
    "text": "11.5 スタックを操作するプログラム例\n上述の関数を使って，整数データのスタックを操作するプログラムを下記のように作成した．写経して実行してみよう．\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// スタックの要素ひとつを表す構造体\ntypedef struct node {\n  int data;\n  struct node *next;\n} Node;\n\n// intデータを保持するスタック\ntypedef struct stack {\n  Node *top;\n} Stack;\n\n// スタックの初期化\nvoid initStack(Stack *s) { s-&gt;top = NULL; }\n\n// プッシュ\nint push(Stack *s, int newdata) {\n  Node *newNode = (Node *)malloc(sizeof(Node));\n  if (newNode == NULL) {  // メモリ領域の確保に失敗したとき\n    return -1;            // 異常値 -1 を呼び出し元に返す\n  }\n\n  newNode-&gt;data = newdata;\n  newNode-&gt;next = s-&gt;top;\n  s-&gt;top = newNode;\n  return 0;\n}\n\n// スタックが空か？\nint isEmpty(Stack *s) { return s-&gt;top == NULL; }\n\n// ポップ\nint pop(Stack *s, int *poppedData) {\n  if (isEmpty(s)) {\n    return -1;\n  }\n  Node *poppedNode = s-&gt;top;\n  *poppedData = poppedNode-&gt;data;\n  s-&gt;top = poppedNode-&gt;next;\n  free(poppedNode);\n  return 0;\n}\n\n// ピーク\nint peek(Stack *s, int *topData) {\n  if (isEmpty(s)) {\n    return -1;\n  }\n  *topData = s-&gt;top-&gt;data;\n  return 0;\n}\n\n// スタックの内容を表示\nvoid printStack(Stack *s) {\n  Node *current = s-&gt;top;\n  while (current != NULL) {\n    printf(\"%d \", current-&gt;data);\n    current = current-&gt;next;\n  }\n  printf(\"\\n\");\n}\n\n// メモリの解放\nvoid freeStack(Stack *s) {\n  Node *current = s-&gt;top;\n  while (current != NULL) {\n    Node *tmp = current;\n    current = current-&gt;next;\n    free(tmp);\n  }\n  s-&gt;top = NULL;\n}\n\nint main(void) {\n  Stack s;\n  initStack(&s);\n\n  while (1) {\n    int menu, x;\n    printf(\"プッシュ(1), ポップ(2), ピーク(3), 表示(4), 終了(0): \");\n    scanf(\"%d\", &menu);\n    if (menu == 0) {\n      break;\n    }\n    switch (menu) {\n      case 1:\n        printf(\"  プッシュするデータ: \");\n        scanf(\"%d\", &x);\n        if (push(&s, x) != 0) {\n          printf(\"プッシュに失敗\\n\");\n        }\n        break;\n      case 2:\n        if (pop(&s, &x) != 0) {\n          printf(\"ポップに失敗\\n\");\n        } else {\n          printf(\"  ポップしたデータ: %d\\n\", x);\n        }\n        break;\n      case 3:\n        if (peek(&s, &x) != 0) {\n          printf(\"ピークに失敗\\n\");\n        } else {\n          printf(\"  ピークしたデータ: %d\\n\", x);\n        }\n        break;\n      case 4:\n        printStack(&s);\n        break;\n      default:\n        break;\n    }\n  }\n  freeStack(&s);\n  return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データ構造 1</span>"
    ]
  },
  {
    "objectID": "week11.html#キューの基本",
    "href": "week11.html#キューの基本",
    "title": "11  データ構造 1",
    "section": "11.6 キューの基本",
    "text": "11.6 キューの基本\n後入れ先出しであるスタックに対して，先入れ先出し（First-In First-Out; FIFO）のデータ構造をキュー（queue）という．待ち行列とも呼ばれ，その名の通り列に並ぶ客が順番に受付されるイメージを持つと理解しやすい．\n\n\n\nキューの概念図．赤矢印は操作を，黒矢印は後の実装例におけるポインタを表す\n\n\nキューに対する基本操作は以下のとおり．\n\nエンキュー（enqueue）\n\nデータをキューの末尾に追加する\n\nデキュー（dequeue）\n\nキューからデータを取り出して，キューから削除する\n\nピーク（peek）\n\nキューの先頭データを取り出すが，キューから削除しない",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データ構造 1</span>"
    ]
  },
  {
    "objectID": "week11.html#キューの実装",
    "href": "week11.html#キューの実装",
    "title": "11  データ構造 1",
    "section": "11.7 キューの実装",
    "text": "11.7 キューの実装\nリスト構造を使ったキューの実装を紹介する． 配列と，データの先頭と末尾を表す2つのポインタでも実装できる．\n\n11.7.1 リスト構造によるキューの実装\nキューを表す構造体Queueは，先頭ノードへのポインタと末尾ノードへのポインタをメンバにもつ．それ以外はスタックの場合とほぼ同様である．\n// キューの要素ひとつを表す構造体\ntypedef struct node {\n  int data;\n  struct node *next;\n} Node;\n\n// intデータを保持するキュー\ntypedef struct {\n  Node *front;\n  Node *rear;\n} Queue;\n\n// キューの初期化\nvoid initQueue(Queue *q) {\n  q-&gt;front = NULL;\n  q-&gt;rear = NULL;\n}\n\n// キューが空か？\nint isEmpty(Queue *q) {\n  return q-&gt;front == NULL;\n}\n\n\n11.7.2 エンキュー\nエンキュー操作では，mallocでNode分のメモリを確保し，与えられたデータを格納してからキューの末尾に接続する．\nint enqueue(Queue *q, int data) {\n  Node *newNode = (Node *)malloc(sizeof(Node));\n  if (newNode == NULL) {\n    return -1;\n  }\n\n  newNode-&gt;data = data;\n  newNode-&gt;next = NULL;\n  if (isEmpty(q)) {\n    q-&gt;front = newNode;\n    q-&gt;rear = newNode;\n  } else {\n    q-&gt;rear-&gt;next = newNode;  // 末尾ノードのnextにnewNodeをつなぐ\n    q-&gt;rear = newNode;        // キューの末尾ポインタを更新\n  }\n  return 0;\n}\n3–5行目は前述のメモリ確保に失敗した場合の例外処理である． 7行目以降の正常系の処理では，新たなノードに引数で指定されたデータを格納する． その後，キューの先頭q-&gt;frontと末尾q-&gt;rearポインタを更新する．既存のキューが空でない場合，末尾ノードのnextポインタにnewNodeを設定することでリストを構成し，更に末尾ポインタq-&gt;rearを新たなノードに更新している．\n\n\n11.7.3 デキュー\nデキュー操作の実装例は以下のとおり．\nint dequeue(Queue *q, int *data) {\n  if (isEmpty(q)) {\n    return -1;\n  }\n\n  Node *f = q-&gt;front;\n  *data = f-&gt;data;\n  q-&gt;front = f-&gt;next;\n  if (q-&gt;front == NULL) {  // キューが空になった場合\n    q-&gt;rear = NULL;        // 末尾ポインタもNULLにしておく\n  }\n  free(f);\n  return 0;\n}\n2–4行目はキューが空の例外処理である． 6行目以降の正常系の処理では，先頭ノードのデータを引数のポインタが指定する先に書き込み（7行目），キューの先頭ポインタq-&gt;frontを更新している．最後に取り出した要素のメモリ解放を行う．\nキューが空になった場合は，末尾ポインタもNULLに初期化している．この記述が無くても，enqueue関数の実装を考えると正常に動作するが，一貫性や安全のためには書いておく方がよい．",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データ構造 1</span>"
    ]
  },
  {
    "objectID": "week11.html#キューを操作するプログラム例",
    "href": "week11.html#キューを操作するプログラム例",
    "title": "11  データ構造 1",
    "section": "11.8 キューを操作するプログラム例",
    "text": "11.8 キューを操作するプログラム例\n上述の関数を使って，キューを操作するプログラムを下記のように作成した．写経して実行してみよう．\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// キューの要素ひとつを表す構造体\ntypedef struct node {\n  int data;\n  struct node *next;\n} Node;\n\n// intデータを保持するキュー\ntypedef struct {\n  Node *front;\n  Node *rear;\n} Queue;\n\n// キューの初期化\nvoid initQueue(Queue *q) {\n  q-&gt;front = NULL;\n  q-&gt;rear = NULL;\n}\n\nint isEmpty(Queue *q) { return q-&gt;front == NULL; }\n\n// エンキュー\nint enqueue(Queue *q, int data) {\n  Node *newNode = (Node *)malloc(sizeof(Node));\n  if (newNode == NULL) {\n    return -1;\n  }\n\n  newNode-&gt;data = data;\n  newNode-&gt;next = NULL;\n  if (isEmpty(q)) {\n    q-&gt;front = newNode;\n    q-&gt;rear = newNode;\n  } else {\n    q-&gt;rear-&gt;next = newNode;  // 末尾ノードのnextにnewNodeをつなぐ\n    q-&gt;rear = newNode;        // キューの末尾ポインタを更新\n  }\n  return 0;\n}\n\n// デキュー\nint dequeue(Queue *q, int *data) {\n  if (isEmpty(q)) {\n    return -1;\n  }\n\n  Node *f = q-&gt;front;\n  *data = f-&gt;data;\n  q-&gt;front = f-&gt;next;\n  if (q-&gt;front == NULL) {  // キューが空になった場合\n    q-&gt;rear = NULL;        // 末尾ポインタもNULLにしておく\n  }\n  free(f);\n  return 0;\n}\n\n// ピーク\nint peek(Queue *q, int *data) {\n  if (isEmpty(q)) {\n    return -1;\n  }\n  *data = q-&gt;front-&gt;data;\n  return 0;\n}\n\nvoid printQueue(Queue *q) {\n  Node *current = q-&gt;front;\n  while (current != NULL) {\n    printf(\"%d \", current-&gt;data);\n    current = current-&gt;next;\n  }\n  printf(\"\\n\");\n}\n\nvoid freeQueue(Queue *q) {\n  int tmp;\n  while (dequeue(q, &tmp) == 0) {\n  }\n}\n\nint main(void) {\n  Queue q;\n  initQueue(&q);\n\n  while (1) {\n    int menu, x;\n    printf(\"エンキュー(1), デキュー(2), ピーク(3), 表示(4), 終了(0): \");\n    scanf(\"%d\", &menu);\n    if (menu == 0) {\n      break;\n    }\n    switch (menu) {\n      case 1:\n        printf(\"  追加するデータ: \");\n        scanf(\"%d\", &x);\n        if (enqueue(&q, x) != 0) {\n          printf(\"エンキューに失敗\\n\");\n        }\n        break;\n      case 2:\n        if (dequeue(&q, &x) != 0) {\n          printf(\"デキューに失敗\\n\");\n        } else {\n          printf(\"  取り出したデータ: %d\\n\", x);\n        }\n        break;\n      case 3:\n        if (peek(&q, &x) != 0) {\n          printf(\"ピークに失敗\\n\");\n        } else {\n          printf(\"  ピークしたデータ: %d\\n\", x);\n        }\n        break;\n      case 4:\n        printQueue(&q);\n        break;\n      default:\n        break;\n    }\n  }\n  freeQueue(&q);\n  return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データ構造 1</span>"
    ]
  },
  {
    "objectID": "week11.html#演習",
    "href": "week11.html#演習",
    "title": "11  データ構造 1",
    "section": "11.9 演習",
    "text": "11.9 演習\n\n11.9.1 問題1\nchar型のデータを格納するスタックを用いて，文字列中のカッコの対応関係をチェックするプログラムを作成せよ．\n\n判定対象のカッコは()と[]とする\nカッコの対応が正常なら1を，不正なら0を返す関数を作成せよ\nテスト文字列に対して正常/不正を判定して出力せよ\n\nテスト文字列1: \"(a[b(c)])\" → 正常\nテスト文字列2: \"([)]\" → 不正（カッコの順序が不正）\nテスト文字列3: \"([()]\" → 不正（対応するカッコがない）\n\n\nヒント：\n\n文字データを格納するノードでスタックをつくる\n与えられた文字列を左から順に読み，開カッコが来たらスタックにプッシュし，閉じカッコがきたらスタックからポップする．ポップした文字と今のカッコが対応していれば正常，そうでなければ不正",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データ構造 1</span>"
    ]
  },
  {
    "objectID": "week12.html",
    "href": "week12.html",
    "title": "12  データ構造 2",
    "section": "",
    "text": "12.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>データ構造 2</span>"
    ]
  },
  {
    "objectID": "week12.html#前回演習の解答",
    "href": "week12.html#前回演習の解答",
    "title": "12  データ構造 2",
    "section": "",
    "text": "スタックの使い方",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>データ構造 2</span>"
    ]
  },
  {
    "objectID": "week12.html#本日のメニュー",
    "href": "week12.html#本日のメニュー",
    "title": "12  データ構造 2",
    "section": "12.2 本日のメニュー",
    "text": "12.2 本日のメニュー\n\nグラフ\nヒープ",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>データ構造 2</span>"
    ]
  },
  {
    "objectID": "week12.html#グラフ",
    "href": "week12.html#グラフ",
    "title": "12  データ構造 2",
    "section": "12.3 グラフ",
    "text": "12.3 グラフ\n頂点（vertex）を表す離散集合\\(V\\)と，頂点間のつながりを表す辺（edge）の集合\\(E\\subseteq V\\times V\\)で構成される\\(G(V, E)\\)をグラフ（graph）と呼ぶ． グラフは，個人間の交友関係や通信機器間のネットワークなど，つながりをもつ複数の要素を表現する記法として用いられる． 頂点のことをノード，辺のことを枝と呼ぶこともある．\n辺に向きの概念があるグラフは有向グラフ（directed graph）といい，そうでない場合は無向グラフ（undirected ）という． 言い換えると，無向グラフでは，任意の頂点\\(p, q\\in V\\)について，\\((p,q)\\in E \\Rightarrow (q,p) \\in E\\)が成り立つ． 無向グラフは有向グラフの特殊ケースである．例えば通信可否がノード間の空間的な距離のみによって決まる場合は\\(p\\)から\\(q\\)への通信が可能ならば逆も可能であるので，無向グラフで表現できる．\n頂点\\(p\\in V\\)から頂点\\(q\\in V\\)へ，辺と頂点を経て到達できる場合，つまり頂点の列\\(p=v_1, v_2, \\dots, v_k = q\\)について\\((v_i,v_{i+1})\\in E\\), \\(i= 1, 2, \\dots, k-1\\)である場合， \\(p\\)-\\(q\\)間に路（path）が存在するという．このとき路の長さは\\(k-1\\)である． 路の頂点が高々一度しか路に現れない場合，つまり\\(v_1, \\dots, v_{k}\\)が相異なる場合，路は単純（simple）という． 路の頂点\\(v_1, \\dots, v_{k-1}\\)が相異なり，\\(v_1 = v_k\\)であるとき，単純閉路という．\nグラフの任意の頂点から任意の頂点への路が存在する場合，そのグラフは連結であるという．有向グラフのときは，有向路が存在すれば強連結，無向グラフに置き換えたときに連結であれば弱連結という．\n以下では無向グラフのみを考える．",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>データ構造 2</span>"
    ]
  },
  {
    "objectID": "week12.html#木",
    "href": "week12.html#木",
    "title": "12  データ構造 2",
    "section": "12.4 木",
    "text": "12.4 木\n連結で単純閉路をもたないグラフを木（tree）という． 木では，特定の頂点を基準に選び（根（root）とよぶ），その他の頂点への路を根から下へ向かう路上に配置した図に書き表すことができる． このとき，根からの路の長さごとに階層を揃えて描く．この階層を深さという．\nある頂点の上，つまり根に近い方の辺でつながった頂点を親といい，下，つまり根から遠ざかる方向に辺でつながった頂点を子という． 子を持たない頂点は葉という．葉は木の末端の頂点である．\n根をもつ木で，頂点の子が高々2つの場合，二分木よぶ． 二分木では，左右の概念を導入して，左の子と右の子を区別する．",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>データ構造 2</span>"
    ]
  },
  {
    "objectID": "week12.html#ヒープの定義",
    "href": "week12.html#ヒープの定義",
    "title": "12  データ構造 2",
    "section": "12.5 ヒープの定義",
    "text": "12.5 ヒープの定義\n\n\n\nヒープの例\n\n\n二分木を構成する頂点に対して順序が定義できる値をひとつ対応させる．例えば頂点に実数をひとつ割り当てる． 以下の条件が成り立つ場合，その二分木1をヒープとよぶ：\n\n葉の深さは\\(d\\)または\\(d-1\\)である（すべての葉の深さの差は高々1）\n深さ\\(d\\)の葉は左詰めに配置されている\n深さ\\(d-1\\)以下の部分について，各頂点はちょうど2個の子をもつ \n葉以外のすべての頂点について，その頂点の値はすべての子の値より小さいか等しい\n\nとくに最後の条件をヒープ条件という2． ヒープ条件から，根の値は最小値である．\n\n1–3番目の条件を言い換えると，根をトップに頂点が上から順に左詰めで並んでいる二分木であると言える． 葉の深さが最大で\\(d\\)のヒープでは，最大で\\(2^0 + 2^1 + \\cdots + 2^d = 2^{d+1} -1\\)個の頂点がある．\nヒープは，データを上下の階層で大小関係が成立する木構造で表現しておくことで，最小値/最大値を素早く取り出すことができる．後述するようにデータの挿入や削除について，データ数\\(n\\)に対して\\(O(\\log n)\\)でヒープを保持したまま操作が可能である．",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>データ構造 2</span>"
    ]
  },
  {
    "objectID": "week12.html#ヒープの実装",
    "href": "week12.html#ヒープの実装",
    "title": "12  データ構造 2",
    "section": "12.6 ヒープの実装",
    "text": "12.6 ヒープの実装\nヒープは配列とデータ数を表す変数を用いて実装できる．\n#define HEAP_SIZE 100\n\ntypedef struct {\n  int data[HEAP_SIZE];\n  int size;\n} Heap;\n\nvoid initHeap(Heap *h) {\n  h-&gt;size = 0;\n}\nヒープの定義から，以下の事実が従う．\n\n\n\n\n\n\nヒープにおける親子のインデックス（親から子）\n\n\n\nヒープの頂点を，根から深さの順に\\(0, 1, 2, \\dots\\)と番号を付ける．同じ深さの頂点は，左から順に並べる． すると，番号\\(i\\)の左の子は（もし存在するなら）番号\\(2i+1\\)，同じく右の子の番号は\\(2i+2\\)である． \n\n\n根の番号を\\(1\\)から始めるとすると，\\(i\\)の左の子は\\(2i\\)，右の子は\\(2i+1\\)である． 頂点の番号づけは上述のように（上詰め左詰めで）順序が決まるので，現在の総データ数だけ保持しておけば配列で表現できる．",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>データ構造 2</span>"
    ]
  },
  {
    "objectID": "week12.html#ヒープの操作",
    "href": "week12.html#ヒープの操作",
    "title": "12  データ構造 2",
    "section": "12.7 ヒープの操作",
    "text": "12.7 ヒープの操作\nデータからどのようにヒープを構築するかは後述するとして，まずは，ヒープが手元にあるとして，ヒープに対する操作を考えよう．\n\n12.7.1 挿入\nヒープに要素を追加するには，まず空いている末尾に追加して，ヒープ条件が成立するまで親子間を入れ替える．実装例は以下のとおり． ある頂点に対応する配列要素のインデックスを\\(i\\)とすると，親のインデックスは\\(\\lfloor (i-1)/2 \\rfloor\\)であることに注意しよう．ここで，\\(\\lfloor \\cdot \\rfloor\\)は小数点以下を切り捨てる床関数である．\n\n\n\n\n\n\nヒープにおける親子のインデックス（子から親）\n\n\n\n子のインデックスを\\(i\\)とすると，親のインデックスは\\(\\lfloor (i-1)/2 \\rfloor\\)である．\n\n\nvoid swap(int *x, int *y) {\n  int tmp = *x;\n  *x = *y;\n  *y = tmp;\n}\n\nvoid insert(Heap *h, int value) {\n  if (h-&gt;size &gt;= HEAP_SIZE) {\n    printf(\"ヒープが満杯です\\n\");\n    exit(1);  // 異常終了 &lt;stdlib.h&gt;が必要\n  }\n\n  // 末尾に追加\n  int i = h-&gt;size;\n  h-&gt;data[i] = value;\n  h-&gt;size++;\n\n  // ヒープ条件を満たすまで親子を入れ替え\n  while (i &gt; 0) {\n    int parent = (i - 1) / 2;\n    if (h-&gt;data[parent] &gt; h-&gt;data[i]) {\n      swap(&h-&gt;data[parent], &h-&gt;data[i]);\n      i = parent;\n    } else {\n      break;\n    }\n  }\n}\n\n\n12.7.2 最小値の削除\nデータの最小値を取り出して削除するには，まず根を取り出して削除し，新たな根として配列末尾の要素を代入する． 新たな根と子がヒープ条件を満たさない場合は，左右の子のうち値が小さい方と入れ替える． 入れ替えた先の階層において，ヒープ条件が成立するか葉になるまで入れ替えを繰り返す． \nint pop(Heap *h) {\n  if (h-&gt;size == 0) {\n    printf(\"ヒープは空です\\n\");\n    exit(1);  // 異常終了\n  }\n  // 最小値を返す\n  int minVal = h-&gt;data[0];\n  // 末尾を根に\n  h-&gt;data[0] = h-&gt;data[h-&gt;size - 1]; // 末尾インデックスは サイズ数 - 1\n  h-&gt;size--;\n\n  // ヒープ化\n  int i = 0;\n  while (1) {\n    int left = 2 * i + 1;\n    int right = left + 1;\n    int smallest = i;  // 入れ替え対象のインデックス\n    // 左の子からヒープ条件をチェック\n    if ((left &lt; h-&gt;size) && (h-&gt;data[left] &lt; h-&gt;data[smallest])) {\n      smallest = left; // 左の子が存在して自分より小さいとき\n    }\n    if ((right &lt; h-&gt;size) && (h-&gt;data[right] &lt; h-&gt;data[smallest])) {\n      smallest = right;\n    }\n    if (smallest != i) {\n      swap(&h-&gt;data[i], &h-&gt;data[smallest]);\n      i = smallest;\n    } else {\n      break;  // 子が存在しない or 子より小さい\n    }\n  }\n  return minVal;\n}\n\n\n12.7.3 ヒープの構築\n与えられた数列からヒープを構築する方法を考えよう．単純に空のヒープに対して前述の挿入を繰り返すと，挿入1回で\\(O(\\log n)\\)であるから\\(O(n\\log n)\\)を要する．\n少し工夫して，\\(O(n)\\)のヒープ化を考えよう． まず，与えられた数列をそのままヒープに当てはめる． つぎに，葉の親，つまり最小の2分木についてヒープ条件を満たすように入れ替えを行う． 葉の親の階層でヒープが構成できたら，その上の階層で同様の操作を行う．\nこのとき，ヒープ条件を満たすような入れ替えは，最小値削除操作における，仮の根をヒープ条件を満たすように下ろしていく操作と同様である． そこで，この操作を別の関数heapifyとしてくくりだし，最小値削除popと共有することができる．\n// 頂点iをヒープ条件を満たすまで下ろす\nvoid heapify(Heap *h, int i) {\n  while (1) {\n    int left = 2 * i + 1;\n    int right = left + 1;\n    int smallest = i;\n    if (left &lt; h-&gt;size && h-&gt;data[left] &lt; h-&gt;data[smallest]) {\n      smallest = left;\n    }\n    if (right &lt; h-&gt;size && h-&gt;data[right] &lt; h-&gt;data[smallest]) {\n      smallest = right;\n    }\n    if (smallest != i) {\n      swap(&h-&gt;data[i], &h-&gt;data[smallest]);\n      i = smallest;\n    } else {\n      break;  // 子が存在しない or 子より小さい\n    }\n  }\n}\n\n// ヒープ構築\nvoid makeHeap(Heap *h, int array[], int n) {\n  if (n &gt; HEAP_SIZE) {\n    printf(\"サイズが大きすぎます\\n\");\n    exit(1);  // 異常終了\n  }\n\n  // 与えられた順にヒープに詰める\n  for (int i = 0; i &lt; n; i++) {\n    h-&gt;data[i] = array[i];\n  }\n  h-&gt;size = n;\n\n  // 最下層の親ノードからヒープ化\n  for (int i = (n - 2) / 2; i &gt;= 0; i--) {\n    heapify(h, i);\n  }\n}\n\n// 最小値を出力してヒープから削除\nint pop(Heap *h) {\n  if (h-&gt;size == 0) {\n    printf(\"ヒープは空です\\n\");\n    exit(1);  // 異常終了\n  }\n  // 最小値を返す\n  int minVal = h-&gt;data[0];\n  // 末尾を根に\n  h-&gt;data[0] = h-&gt;data[h-&gt;size];\n  h-&gt;size--;\n\n  // ヒープ化\n  heapify(h, 0);\n \n  return minVal;\n}\n関数makeHeapの最後のfor文（36行目）では，子をもつ最下層の頂点から上の階層に向かって順に処理を行う． 配列のインデックス\\(i\\)に対応する頂点の親は，\\(\\lfloor (i-1)/2 \\rfloor\\)であるから，配列の要素数を\\(n\\)として，最後の要素\\(n-1\\)の親のインデックスは\\(\\lfloor (n-2)/2 \\rfloor\\)である． \n\n\n\n\n\n\nヒープの実装例まとめ\n\n\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define HEAP_SIZE 100\n\ntypedef struct {\n  int data[HEAP_SIZE];\n  int size;\n} Heap;\n\nvoid initHeap(Heap *h) { h-&gt;size = 0; }\n\nvoid swap(int *x, int *y) {\n  int tmp = *x;\n  *x = *y;\n  *y = tmp;\n}\n\n// データの挿入\nvoid insert(Heap *h, int value) {\n  if (h-&gt;size &gt;= HEAP_SIZE) {\n    printf(\"ヒープが満杯です\\n\");\n    exit(1);  // 異常終了\n  }\n\n  // 末尾に追加\n  int i = h-&gt;size;\n  h-&gt;data[i] = value;\n  h-&gt;size++;\n\n  // ヒープ条件を満たすまで親子を入れ替え\n  while (i &gt; 0) {\n    int parent = (i - 1) / 2;\n    if (h-&gt;data[parent] &gt; h-&gt;data[i]) {\n      swap(&h-&gt;data[parent], &h-&gt;data[i]);\n      i = parent;\n    } else {\n      break;\n    }\n  }\n}\n\n// 頂点iをヒープ条件を満たすまで下ろす\nvoid heapify(Heap *h, int i) {\n  while (1) {\n    int left = 2 * i + 1;\n    int right = left + 1;\n    int smallest = i;\n    if (left &lt; h-&gt;size && h-&gt;data[left] &lt; h-&gt;data[smallest]) {\n      smallest = left;\n    }\n    if (right &lt; h-&gt;size && h-&gt;data[right] &lt; h-&gt;data[smallest]) {\n      smallest = right;\n    }\n    if (smallest != i) {\n      swap(&h-&gt;data[i], &h-&gt;data[smallest]);\n      i = smallest;\n    } else {\n      break;  // 子が存在しない or 子より小さい\n    }\n  }\n}\n\n// 数列からヒープを構築\nvoid makeHeap(Heap *h, int array[], int n) {\n  if (n &gt; HEAP_SIZE) {\n    printf(\"サイズが大きすぎます\\n\");\n    exit(1);  // 異常終了\n  }\n\n  // 与えられた順にヒープに詰める\n  for (int i = 0; i &lt; n; i++) {\n    h-&gt;data[i] = array[i];\n  }\n  h-&gt;size = n;\n\n  // 最下層の親ノードからヒープ化\n  for (int i = (n - 2) / 2; i &gt;= 0; i--) {\n    heapify(h, i);\n  }\n}\n\n// 最小値を出力してヒープから削除\nint pop(Heap *h) {\n  if (h-&gt;size == 0) {\n    printf(\"ヒープは空です\\n\");\n    exit(1);  // 異常終了\n  }\n  // 最小値を返す\n  int minVal = h-&gt;data[0];\n  // 末尾を根に\n  h-&gt;data[0] = h-&gt;data[h-&gt;size - 1];\n  h-&gt;size--;\n\n  // ヒープ化\n  heapify(h, 0);\n  return minVal;\n}\n\n// ヒープ内容表示\nvoid printHeap(Heap *h) {\n  for (int i = 0; i &lt; h-&gt;size; i++) {\n    if ((i & (i + 1)) == 0) {\n      printf(\"/ \");  // 階層の区切り\n    }\n    printf(\"%d \", h-&gt;data[i]);\n  }\n  printf(\"\\n\");\n}\n\nint main() {\n  int a[] = {10, 3, 5, 7, 2, 8, 1, 13};\n  int n = sizeof(a) / sizeof(a[0]);\n  Heap h;\n  initHeap(&h);\n  makeHeap(&h, a, n);\n  printHeap(&h);\n\n  printf(\"最小値: %d\\n\", pop(&h));\n  printHeap(&h);\n\n  int x = 6;\n  printf(\"データ %d を挿入\\n\", x);\n  insert(&h, x);\n  printHeap(&h);\n\n  return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>データ構造 2</span>"
    ]
  },
  {
    "objectID": "week12.html#演習問題",
    "href": "week12.html#演習問題",
    "title": "12  データ構造 2",
    "section": "12.8 演習問題",
    "text": "12.8 演習問題\n\n12.8.1 問題1\nヒープを使って実数列を昇順に並び替える（ソート）プログラムを作成せよ． * テスト数列: \\(10, 3, 5, 7, 2, 8, 1, 13\\) → \\(1, 2, 3, 5, 7, 8, 10, 13\\)\n\n\n12.8.2 問題2\n問題1の計算量を説明せよ．",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>データ構造 2</span>"
    ]
  },
  {
    "objectID": "week12.html#footnotes",
    "href": "week12.html#footnotes",
    "title": "12  データ構造 2",
    "section": "",
    "text": "二分木以外のヒープもある．区別する場合は二分ヒープとよぶ．↩︎\nヒープ条件の大小関係を逆に定義する場合もある．↩︎",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>データ構造 2</span>"
    ]
  }
]