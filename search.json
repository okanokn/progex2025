[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "プログラミング演習",
    "section": "",
    "text": "目次\n2025年度プログラミング演習 Bクラスの授業資料です．\n\n第1週，+R授業\n第2週\n第3週\n第4週\n第5週\n第6週\n第7週\n第8週\n第9週\n第10週\n第11週\n第12週\n第13週\n第14週\n\n本資料を作成するに当たり，毛利先生（Aクラス担当）の授業資料，松井勇佑先生の授業資料を参考にさせていただきました．",
    "crumbs": [
      "目次"
    ]
  },
  {
    "objectID": "week01.html",
    "href": "week01.html",
    "title": "1  ガイダンス・環境構築",
    "section": "",
    "text": "1.1 +R授業のコンテンツ\n+R授業では，C言語プログラムの開発環境について，オンライン・オフラインそれぞれの環境設定方法を説明する．オンライン環境については，Google Cloud Shell Editorの使い方を本稿で述べる．オフライン環境については，毛利先生による解説動画を別途アップロードする．\n本講義（プログラミング演習Bクラス）では，オンラインの開発環境としてGoogle Cloud Shell Editorを推奨する．Googleアカウントが必要となるので，アカウントを取得できない場合や，本講義でアカウントを使用したくない場合は，オフライン環境を使用すること．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#google-cloud-shell-editorについて",
    "href": "week01.html#google-cloud-shell-editorについて",
    "title": "1  ガイダンス・環境構築",
    "section": "1.2 Google Cloud Shell Editorについて",
    "text": "1.2 Google Cloud Shell Editorについて\nインターネットを経由してGoogle社が管理するサーバに接続すると，サーバ内で仮想マシンが起動する．Googleアカウントがあれば無料で使用できるが，いくつか使用上の制限がある:\n\n1週間の使用時間が50時間以下に制限される\n20分間キー入力がないと接続が切断され，再接続が必要となる（作成したファイルは残る）\n120日間アクセスがない場合はホームフォルダの中身が自動的に削除される\nストレージサイズは5 GB\n\n\n\n\n\n\n\nTip\n\n\n\n仮想マシンのOSは，DebianベースのLinux OSとのこと1．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#エディタを起動する",
    "href": "week01.html#エディタを起動する",
    "title": "1  ガイダンス・環境構築",
    "section": "1.3 エディタを起動する",
    "text": "1.3 エディタを起動する\nまずはエディタを起動してみよう：\n\nGoogle Cloud Shell Editor (https://ide.cloud.google.com/) にアクセスする\nGoogleアカウントにログインしていない場合は，ダイアログに従ってログインする\nしばらく待つと仮想マシンが起動する\n\n起動直後は下図のような画面である．右端にGeminiの広告パネルが表示されている場合は，✕ボタンで閉じてよい．\n\n左上の File メニューからOpen Folderを選択して，ホームフォルダを開いてみよう．Open Folderという青いボタンからでもよい．ホームフォルダは，/home/自分のGoogleアカウント名である．\n左側のペインに開いているフォルダ内のファイルが一覧で表示される．初期状態ではREADME-cloudshell.txtが存在しているはず\n\n右上のペンマークのとなりのボタンを押すと，ターミナルウィンドウが表示される．\n\nターミナルとは，テキストコマンドでコンピュータの操作を行うためのアプリケーションである．（仮想）端末とも呼ばれる．Windowsでは古くはコマンドプロンプト，最近ではWindows Terminalがある．\nプログラムのコンパイル，コンパイルしたプログラムの実行などをターミナルにコマンドを入力することで行う．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#ターミナルを使ってみる",
    "href": "week01.html#ターミナルを使ってみる",
    "title": "1  ガイダンス・環境構築",
    "section": "1.4 ターミナルを使ってみる",
    "text": "1.4 ターミナルを使ってみる\nターミナルにコマンドを打ち込んでコンピュータを操作する練習をしてみよう．\n現在の作業フォルダを表示するコマンドpwdを$マークの右側に打ち込み，EnterEnterキーで実行する．\nkunihisa_okano@cloudshell:~$ pwd\n/home/kunihisa_okano\n1行目の$の右側が入力したコマンド，2行目は実行結果を示している．kunihisa_okanoは筆者のGoogleアカウント名である． なお，$の左側は，ログイン名@マシン名:カレントフォルダ$を表す． 以後のコマンド例では$の右側のみを記述する．\nファイルの中身をテキストで表示するcatコマンドを使ってみよう．\ncat README-cloudshell.txt # 実行するとファイルの中身がターミナルに表示される\nここで，表示したいファイル名README-cloudshell.txtをすべて手動で入力する必要はない．RRのあとにTabTabキーを押せば，作業フォルダ内でRから始まるファイル名を自動的に補完してくれる．\n現在のフォルダに，テスト用のフォルダtest_dirを作成しよう．mkdirコマンド2で作成して，lsコマンドで作成結果を確認する：\nmkdir test_dir # test_dir という名前のフォルダを作成\nls # ファイル一覧が表示される．新たに test_dir が追加されている\n#以降はコメントなので入力する必要はない．\n作成したディレクトリtest_dirに作業ディレクトリを移動しよう．cdコマンドを使う．\ncd test_dir # test_dirへ移動\npwd # 移動できたか確認する\nフォルダ階層を相対パスで表すには，., ..を使う．\n\n. 現在のフォルダ\n.. 一つ上の階層\n~ ホームフォルダ\n\nたとえば，一つ上のフォルダに移動したい場合はつぎのようにする．\ncd .. # ひとつ上のフォルダに移動\ncd test_dir # 戻る\nこのほか，以下のコマンドはよく使う．\n\nmv ファイルを移動，名前の変更\ncp ファイルをコピー\nrm ファイルを削除",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#c言語ソースファイルの作成とコンパイル",
    "href": "week01.html#c言語ソースファイルの作成とコンパイル",
    "title": "1  ガイダンス・環境構築",
    "section": "1.5 C言語ソースファイルの作成とコンパイル",
    "text": "1.5 C言語ソースファイルの作成とコンパイル\ntest_dirにhello.cというC言語のソースファイルを作成してみよう．\ntouch hello.c # 作業フォルダに hello.c という名前の新規ファイルを作成\nファイル一覧領域でhello.cを選択すると，エディタ領域でこのファイルを編集できる．\n\nhello.cを編集して，標準出力にHellow worldというテキストを出力するプログラムを作成しよう．\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"Hello world\\n\");\n    return 0;\n}\n作成したファイルをコンパイルするには，ターミナルでgccを呼び出す．\ngcc hello.c\nプログラム中にタイプミスなどがあると，コンパイラが警告やエラーを出力する．メッセージを読んで該当箇所を修正しよう．\nコンパイルによって作成した実行ファイルは，自動的にa.outという名前がつけられる． これを実行してみよう．\n./a.out # Hello world と表示される\n行頭の./は，a.outという実行ファイルが現在のフォルダに存在することを示す．a.outはコマンドとしてコンピュータが認識していないので，どこのa.outなのか，実行するファイルの所在地を明示的に記述する必要がある．\n\n\n\n\n\n\nTip\n\n\n\n実行ファイル名をa.out以外にするには，gcc hello.c -o helloのようにoオプションの後に実行ファイル名を記述する．実行するときは，./helloとする．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#作成したファイルをローカルpcに保存する",
    "href": "week01.html#作成したファイルをローカルpcに保存する",
    "title": "1  ガイダンス・環境構築",
    "section": "1.6 作成したファイルをローカルPCに保存する",
    "text": "1.6 作成したファイルをローカルPCに保存する\n作成したソースコードをローカルPCに保存するには，保存したいファイルを選択した状態でFileメニュー &gt; Save As を選択して，\n\n表示されるダイアログで，Show Localを選択する．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#オフライン環境の構築方法",
    "href": "week01.html#オフライン環境の構築方法",
    "title": "1  ガイダンス・環境構築",
    "section": "1.7 オフライン環境の構築方法",
    "text": "1.7 オフライン環境の構築方法\nWindowsユーザーの場合は，別途アップロードする毛利先生による解説動画を参照する．\nmacOSユーザーの場合は，App StoreからXcodeをインストールする． Xcodeは容量が大きいので，ストレージ容量が気になる場合は，Command Line Toolsをインストールする．\nxcode-select --install\nエディタは好きなものを使えばよいが，Visual Studio Code を推奨する．",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week01.html#footnotes",
    "href": "week01.html#footnotes",
    "title": "1  ガイダンス・環境構築",
    "section": "",
    "text": "https://cloud.google.com/shell/docs/how-cloud-shell-works↩︎\nMake directoryの略．↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ガイダンス・環境構築</span>"
    ]
  },
  {
    "objectID": "week02.html",
    "href": "week02.html",
    "title": "2  C言語の復習 1",
    "section": "",
    "text": "2.1 本日のメニュー",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#本日のメニュー",
    "href": "week02.html#本日のメニュー",
    "title": "2  C言語の復習 1",
    "section": "",
    "text": "演算子\n型\n分岐 (if)\n繰り返し (for)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#準備",
    "href": "week02.html#準備",
    "title": "2  C言語の復習 1",
    "section": "2.2 準備",
    "text": "2.2 準備\nGoogle Cloud Shell Editor (https://ide.cloud.google.com/)を立ち上げて，ホームフォルダ(/usr/自分のgoogleアカウント名)を開く． ホームフォルダに今日の演習ファイルを格納するフォルダ02を作成して，ターミナルの作業フォルダを/usr/自分のgoogleアカウント名/02に移動させる．\n\n\n\nコマンド\n用途\n用例\n\n\n\n\npwd\n現在の作業フォルダを表示\npwd\n\n\nmkdir\nフォルダを生成\nmkdir 02\n\n\ncd\n作業フォルダを移動\ncd 02\n\n\ntouch\n新規ファイル生成\ntouch hoge.c",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#四則演算",
    "href": "week02.html#四則演算",
    "title": "2  C言語の復習 1",
    "section": "2.3 四則演算",
    "text": "2.3 四則演算\n整数を2つ読み込み，それらの足し算，引き算，掛け算，割り算の計算結果と，割り算の余りを表示するプログラムcalc2int.cを作成しよう．\n数値を入力するメッセージの表示はprintf関数で，入力された数値の読み込みはscanf関数で行う．\nint a;\nprintf(\"1番目の整数を入力してください: \");\nscanf(\"%d\", &a);\n四則演算を行う演算子を復習しよう．\nprintf(\"a + b = %d\\n\", a + b); // a+b\nprintf(\"a - b = %d\\n\", a - b); // a-b\nprintf(\"a * b = %d\\n\", a * b); // a*b\nprintf(\"a / b = %d\\n\", a / b); // a/bの商を表示 !注意!\nprintf(\"a %% b = %d\\n\", a % b); // bをaで割った余りを表示\nたとえばa = 2, b = 3のように代入した場合，a/bの計算結果は電卓で2/3を計算した結果と異なり，0が出力される． これは，a, bがともに整数を表すint型であることと，printfの出力形式%dが整数値書式となっているため．\nprintf中で，パーセント記号は出力書式を表す特殊文字として使われるので，%と書くだけではパーセント記号を出力しない． パーセント記号自身を文字として表示したい場合は，%%のように2回続けて記述する1．\n計算に用いる値に小数が含まれている場合は，自動的に小数で計算される．\nprintf(\" 2 / 3 = %d\\n\", 2/3);         // 小数点以下を切り捨てた 0\nprintf(\" 2.0 / 3 = %d\\n\", 2.0/3);     // 小数で計算されるが出力書式がint指定なので変な値に\nprintf(\" 2.0 / 3 = %f\\n\", 2.0/3);     // 0.666667 (内部的には更に下の桁まで計算されている)\nprintf(\" 2.0 / 3.0 = %f\\n\", 2.0/3.0); // 0.666667 (内部的には更に下の桁まで計算されている)\n\n\n\n\n\n\n負の数を用いた除算\n\n\n\n少なくとも1つが負の数の場合，/の計算結果が「商以下の最大の整数」となるか「商以上の最小の整数」となるかは，処理系に依存する．",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#型",
    "href": "week02.html#型",
    "title": "2  C言語の復習 1",
    "section": "2.4 型",
    "text": "2.4 型\n基本的には，整数はint，小数にはdoubleを使う．\n\n\n\n\n\n\n\n\n\n\n型\n用途\nバイト数\n範囲(処理系依存)\n書式指定子\n\n\n\n\nchar\n文字\n1\n\\(-127\\)–\\(128\\)\n%c,%s\n\n\nint\n整数\n4\n\\(-32768\\)–\\(32767\\)\n%d\n\n\nlong\n整数\n4\n\\(-2147483648\\)–\\(2147483647\\)\n%ld\n\n\nunsigned char\n文字\n2\n\\(0\\)–\\(255\\)\n%c,%s\n\n\nunsigned int\n符号なし整数\n4\n\\(0\\)–\\(65535\\)\n%u\n\n\nunsigned short\n符号なし整数\n2\n\\(0\\)–\\(65535\\)\n%hu\n\n\nunsigned long\n符号なし整数\n4\n\\(0\\)–\\(4294967295\\)\n%lu\n\n\nfloat\n単精度浮動小数点数\n4\n有効桁数6–7\n%f\n\n\ndouble\n倍精度浮動小数点数\n8\n有効桁数15–16\n%lf\n\n\n\n\n\n\n\n\n\n\nintとdoubleの演算ではintで宣言された変数の値が自動的にdoubleに変換されて計算が行われる． どのような場合に暗黙の型変換が行われるかを網羅的に書くことは難しいが，とりあえずはintとdoubleの関係について知っておけばよい．\n明示的に型変換を行いたい場合は，(型名)(変換対象の式)のように書く． これをキャストという．\nint a = 1;\nint b = 2;\ndouble c = (double)(a + b) / 2 // intのa+bをdoubleに変換してから 2 で除す→計算結果はdouble",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#分岐-if",
    "href": "week02.html#分岐-if",
    "title": "2  C言語の復習 1",
    "section": "2.5 分岐 if",
    "text": "2.5 分岐 if\nプログラムの処理を，条件によって分岐させるにはif文を使う． 次のプログラムは，入力された整数が偶数の場合，そのように出力するプログラム（の一部）である． evenorodd.cというファイルを作成し，以下の内容を書き写して実行してみよう．\nint a;\nprintf(\"整数を入力してください: \");\nscanf(\"%d, &a\");\nif(a % 2 == 0){\n  printf(\"aは偶数です\\n\");\n}\nif(式)で式の真偽によってプログラムの実行が分岐する．式が真の場合のみifの直後のブロックが実行される．ブロックとは，{}で囲われた部分のことである．\nさらに，式が偽の場合の動作を別途指定したい場合は，elseを使う．\nint a;\nprintf(\"整数を入力してください: \");\nscanf(\"%d, &a\");\nif(a % 2 == 0){\n  printf(\"aは偶数です\\n\");\n}else{\n  printf(\"aは奇数です\\n\");\n}\n最初の式が偽の場合に，さらに別の条件で分岐を行う場合はelse ifを使う．\nint a;\nprintf(\"整数を入力してください: \");\nscanf(\"%d, &a\");\nif(a &lt; 0){\n  printf(\"aは負の数です\\n\");\n}else if (a % 2 == 0){\n  printf(\"aは正の偶数です\\n\");\n}else{\n  printf(\"aは正の奇数です\\n\");\n}\nまた，if文のなかにif文を書くこともできる． 次のプログラムは，上のプログラムと同一だが，elseの中に別のif文が入っている．\nint a;\nprintf(\"整数を入力してください: \");\nscanf(\"%d, &a\");\nif(a &lt; 0){\n  printf(\"aは負の数です\\n\");\n}else{\n  if (a % 2 == 0){\n    printf(\"aは正の偶数です\\n\");\n  }else{\n    printf(\"aは正の奇数です\\n\");\n  }\n}\nこのように，ブロックの中に別のブロックが入る場合は，インデント（行頭の空白文字の長さ）をブロックの深さごとに変えて，視覚的にプログラムの構造を表すとよい． 多くのエディタではインデントを自動的に整形する機能がついている． Google Cloud Shell EditorではFormat Documentコマンドで整形できる． これを呼び出すには，でメニューを呼び出し，Format Documentと入力するか，のショートカットキーを使う．\n条件に大小関係を用いる場合は，関係演算子を用いて記述する．\n\n\n\n演算子\n用例\n意味\n\n\n\n\n&lt;\na &lt; b\naがb未満ならば真，そうでなければ偽\n\n\n&gt;\na &gt; b\naがbより大きければ真，そうでなければ偽\n\n\n&lt;=\na &lt;= b\naがb以下ならば真，そうでなければ偽 (=&lt;は不可)\n\n\n&gt;=\na &gt;= b\naがb以上ならば真，そうでなければ偽 (=&gt;は不可)\n\n\n==\na == b\naとbが等しければ真，そうでなければ偽\n\n\n!=\na != b\naとbが異なれば真，そうでなければ偽\n\n\n\n式で複数の条件を複合したい場合は，\n\n&& AND, 論理積\n|| OR, 論理和\n! NOT, 否定\n\nを組合わせて表現します．\n\n\n\n\n\n\n真偽を表す数値\n\n\n\nC言語では，整数0が偽を表し，それ以外は真を表す． 真を表す数値を明示的に書く場合には1がよく用いられるが，1以外も0でなければ真であることに注意．",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#分岐-switch",
    "href": "week02.html#分岐-switch",
    "title": "2  C言語の復習 1",
    "section": "2.6 分岐 switch",
    "text": "2.6 分岐 switch\n3つ以上の処理に分岐したい場合はswitch文を使うことができる． 以下は，入力された整数の剰余を計算して，その値によってテキストを出力するプログラムである． mod3.cというファイルを作成し，以下の内容を書き写して実行してみよう．\nint a;\nprintf(\"整数を入力してください: \");\nscanf(\"%d\", &a);\n\nswitch(a % 3){\n  case 0 :\n    printf(\"3で割り切れます\\n\");\n    break;\n  case 1 :\n    printf(\"3で割った余りは1です\\n\");\n    break;\n  case 2 :\n    printf(\"3で割った余りは2です\\n\");\n    break;\n  default :\n    printf(\"剰余が0, 1, 2のいずれでもありません\\n\");\n}\nswitch文は次のような構造になっている．\nswitch(式){\n  case 定数式: 文\n  case 定数式: 文\n  default: 文\n}\n式の値が，caseのあとに続く定数式に合致する箇所にジャンプし，それ以後の文を実行する． defaultは，どのcaseにも合致しない場合に実行される． breakは，その行でswitch文のブロックを抜ける動作をする． つまり，switch文直後のブロックの後に処理が移動する． もしbreakが無いと，その後のcaseの文も実行される． （個人的には，switchを使わずにifで書いたほうがわかりやすいと思う．）",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#繰り返し-for",
    "href": "week02.html#繰り返し-for",
    "title": "2  C言語の復習 1",
    "section": "2.7 繰り返し for",
    "text": "2.7 繰り返し for\n繰り返し特定の処理を行いたい場合はfor文を使う． 以下のプログラムは，“hello world”を10回繰り返して出力する． “world”の後には繰り返し回数を表示する． hello10.cというファイルを作成し，以下の内容を書き写して実行してみよう．\nint i;\nfor(i=0; i &lt; 10; i = i + 1){\n  printf(\"hello world %d\\n\", i+1);\n}\nfor文は以下のような構造をもつ:\nfor(式1; 式2; 式3)\nまず式1を実行し，つぎに式2を評価する． 評価結果が真であればfor文の直後のブロックを実行する． その後，式3を実行して式2の真偽評価に戻る． これを，式2の評価が偽となるまで繰り返す．\n\n\n\n\n\n\n無限ループを止める\n\n\n\n無限ループを含むプログラムを実行して入力を受け付けなくなってしまった場合は，ターミナル上でControl-CControl-Cを押すと止まる．",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#演習",
    "href": "week02.html#演習",
    "title": "2  C言語の復習 1",
    "section": "2.8 演習",
    "text": "2.8 演習\n以下の問題に取り組み，ソースコードをmanaba+Rにアップロードせよ．",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#問題1",
    "href": "week02.html#問題1",
    "title": "2  C言語の復習 1",
    "section": "2.9 問題1",
    "text": "2.9 問題1\n3つの整数値を読み込み，それらの平均を表示するプログラムave3int.cを作成せよ",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#問題2",
    "href": "week02.html#問題2",
    "title": "2  C言語の復習 1",
    "section": "2.10 問題2",
    "text": "2.10 問題2\n1つの整数値を読み込み，最も下の桁の数を表示するプログラムleastdigit.cを作成せよ",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#問題3",
    "href": "week02.html#問題3",
    "title": "2  C言語の復習 1",
    "section": "2.11 問題3",
    "text": "2.11 問題3\n整数値を読み込み，その回数だけおみくじの結果を表示するプログラムomikuji.cを作成せよ．ただし，おみくじは「大吉」，「吉」，「小吉」，「凶」，「大凶」のいずれかを等確率で選択するとする\n\nstdlib.hを読み込んでrand()を使うと整数の乱数を作成できる\n乱数の範囲は0からRAND_MAXで指定されている",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week02.html#footnotes",
    "href": "week02.html#footnotes",
    "title": "2  C言語の復習 1",
    "section": "",
    "text": "このエスケープ方法はprintf関数に直接%%を書く場合のみ有効．たとえばputs(\"%%\");や，char a[5]; strcpy(a, \"%%\"); printf(\"%s\", a);は%%を出力する．↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>C言語の復習 1</span>"
    ]
  },
  {
    "objectID": "week03.html",
    "href": "week03.html",
    "title": "3  C言語の復習 2",
    "section": "",
    "text": "3.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#前回演習の解答",
    "href": "week03.html#前回演習の解答",
    "title": "3  C言語の復習 2",
    "section": "",
    "text": "intのみの演算で小数となる場合はdoubleにキャストする\nブロック構造を可視化するためにインデントを揃える\n複数の条件の論理演算\n\n0 &lt;= a &lt;= 1は不可．0 &lt;= a && a &lt;= 1\nif文条件式の順番\n\n\n\n\n\n\n\n\nTip\n\n\n\nprintfと入力すると，format:という文言が自動補完機能で追加される．邪魔なので補完機能をオフに設定するとよい1: 画面左下の歯車アイコン &gt; Settings &gt; 検索ボックスにinlayと入力 &gt; Inlay Hints: Enabledをoffに設定 &gt; Settingsタブを閉じる",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#今日のメニュー",
    "href": "week03.html#今日のメニュー",
    "title": "3  C言語の復習 2",
    "section": "3.2 今日のメニュー",
    "text": "3.2 今日のメニュー\n\n繰り返し while, do while\n配列",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#繰り返し-while",
    "href": "week03.html#繰り返し-while",
    "title": "3  C言語の復習 2",
    "section": "3.3 繰り返し while",
    "text": "3.3 繰り返し while\nwhile文の構成は以下のとおり:\nwhile(式){文}\n式が真である場合，文を実行し，式の評価に戻る．偽の場合は直後のブロック{}の後にジャンプする． 式が定数式の場合は真偽が変わらないので，真ならば文を無限回実行するプログラムとなり，偽ならば文は一度も実行されない．\n以下は，入力された整数aとa+9の間の整数を出力するプログラム（の一部）である．\nint a, amax;\n\nprintf(\"整数を入力: \");\nscanf(\"%d\", &a);\n\namax = a + 9;\nwhile (a &lt;= amax) {\n  printf(\"%d \", a);\n  a = a + 1;\n}\nwhileの条件式に変数aが含まれており，繰り返し実行するブロック中でaの値が変更されていることに注意． 例えば，3行目で10が入力された場合，aは10，amaxは19である． while文のブロック中で，aは値を出力した後インクリメントされる． 10回目のループでaに20が代入されると，11回目の条件式評価ではa &lt;= amaxが偽となり，{}の中を実行することなく10行目のブロック直後にジャンプする．\n\n\n\n\n\n\n【再掲】無限ループを止める\n\n\n\n無限ループを含むプログラムを実行して入力を受け付けなくなってしまった場合は，ターミナル上でControl-CControl-Cを押すと止まる．",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#繰り返し-do-while",
    "href": "week03.html#繰り返し-do-while",
    "title": "3  C言語の復習 2",
    "section": "3.4 繰り返し do while",
    "text": "3.4 繰り返し do while\nwhile文と似ているが，ブロックを実行してから，その後に繰り返し条件式を判断する構文もある．\ndo{文}while(式);\nまず文を実行し，式が真であればもう一度，文を実行する．偽であれば次の行に移動する．\n次のプログラム（の一部）は入力された整数を出力する動作を繰り返す．\nint a;\ndo{\n  printf(\"整数を入力: \");\n  scanf(\"%d\", &a);\n  printf(\"--&gt; 入力された数: %d\\n\", a);\n  printf(\"終了する場合は 0 を入力: \");\n  scanf(\"%d\", &a);\n} while (a);\nwhile (a)は，aが真を表す値である0以外のとき条件式が真となりブロックの先頭に戻る． それ以外，つまり0のときは偽となり繰り返しを終了する．\n\n\n\n\n\n\n【再掲】真偽を表す数値\n\n\n\nC言語では，整数0が偽を表し，0以外は真を表す． 真を表す数値を明示的に書く場合には1がよく用いられるが，1以外も0でなければ真であることに注意．",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#インクリメント複合代入",
    "href": "week03.html#インクリメント複合代入",
    "title": "3  C言語の復習 2",
    "section": "3.5 インクリメント，複合代入",
    "text": "3.5 インクリメント，複合代入\n繰り返し文で1ずつ値を増加（減少）させたい場合は，増分演算子（減分演算子）を使うと短く記述できる．\n\na++ aの値を1だけ増加させる\na-- aの値を1だけ減少させる\n\nこのような動作をインクリメント（デクリメント）という． while文のサンプルプログラムでa = a + 1;としているところは，a++;に置き換えることができる．\nさらに，以下のように書くこともできる．\nwhile (a &lt;= amax) {\n  printf(\"%d \", a++);\n}\naの値をprintfに渡して出力してから，aの値を1増加させる動作をする． aの値を先に増加させてからprintfで出力したい場合は，++をaの前につける．\nwhile (a &lt;= amax) {\n  printf(\"%d \", ++a);\n}\nインクリメントの前置と後置はややこしいが，筆者の主観では後置を使うべき場面はそんなに多くない．\nインクリメントのように1ずつの増減に限らず，変数にある数を加える動作はよく使う． a = a + summandはa += summandと書くことができる．このような演算子を複合代入演算子と呼ぶ．\n\n\n\n用例\n意味\n\n\n\n\na += b\na = a + b\n\n\na -= b\na = a - b\n\n\na *= b\na = a * b\n\n\na /= b\na = a / b\n\n\na %= b\na = a % b\n\n\n\nこのほか，ビット演算子である&, |などに対応する複合代入演算子もある．\n\n\n\n\n\n\nNote\n\n\n\n数学で加減より乗除の計算が優先されるように，プログラミング言語の演算子にも優先順位がある． たとえばa * b &lt; 10は乗算*が比較&lt;より優先度が高いので，a*bの値が10より小さければ真となる（b &lt; 10の真偽値にaをかけることにはならない）．インクリメントや&&など複雑な式では動作が分かりづらくなるので，優先する動作を()で囲うとよい．",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#配列",
    "href": "week03.html#配列",
    "title": "3  C言語の復習 2",
    "section": "3.6 配列",
    "text": "3.6 配列\n同じデータ型をまとめて多数扱う場合には，配列として宣言するとよい． 配列を宣言するには，下記のように書く．\n型 変数名[要素数];\nたとえば，10名のテストの点数を格納する配列scoreは，\nint score[10];\nである．\n配列を宣言すると，データ型のバイト数✕配列要素数だけ連番でメモリ上に領域が確保される． 上の例では，intの4バイトを30個分，連続した領域が確保される． C言語では配列の宣言時にサイズを確定する必要がある2．\n配列の要素に値を代入するには次のように書く．\nscore[0] = 99;\nscore[1] = 80;\n配列の要素番号は0からスタートすることに注意が必要． つまり，配列の最後の要素の番号は，要素数-1である．\nscore[9] = 100;  // 10番目の要素\nscore[10] = 99;  // 実行時にエラー\n宣言と同時に値を代入する場合には，以下のように書く（配列の初期化という）．\nint score[] = {99, 80, 75, 66, 50, 87, 33, 89, 99, 100};\nscore[10]のように要素数を指定してもよいし，省略してもよい． ただし，省略できるのは宣言と同時に値を代入する場合に限る． 値を指定せずに宣言だけ行う場合には要素数を省略できない．\n\n\n\n\n\n\n2025/04/28 追記\n\n\n\n配列の要素数を指定して宣言し，宣言と同時に一部の要素を初期化した場合，値を指定していない残りの要素は0で初期化される． たとえば，\nint score[10] = {99, 80};\nのようにscore配列を宣言してscore[0]とscore[1]を99と80で初期化する．残りの要素score[3]からscore[9]は0で初期化される．これを応用して，scoreの値をすべて0で初期化したいときに\nint score[10] = {0};\nのように10個の0を並べることなく初期化できる．このような書き方は初期化のみ，つまり宣言と同時に値を代入するときのみ可能．また，値をひとつも指定しない場合は不定値で初期化されることに注意．\n\n\n配列の値は，変数名と要素番号を用いて参照できる．\nfor(int i = 0; i &lt; 10; i++){\n  printf(\"%d 番: %d点\\n\", i, score[i]);\n}\nここまで1次元の配列を考えたが，連番を2次元以上に設定することもできる． たとえば，前述の10名のテスト点数を5科目分に拡張したい場合は次のように書く．\nint score[5][10];\nこれは，score[0][0]→score[0][1]→…→score[0][9]→score[1][0]→…→score[4][9]のように先のインデックスが上位桁，後のインデックスが下位桁の連番となるようにメモリ領域を確保する．\n多次元配列の初期化は，要素ごとに値を代入するか，以下のように書く．\nint score[][10] = {\n  {99, 80, 75, 66, 50, 87, 33, 89, 99, 100},\n  {91, 98, 4,  4,  39, 68, 26, 26, 84, 6},\n  {92, 49, 94, 5,  80, 17, 70, 25, 55, 78},\n  {64, 81, 68, 10, 19, 12, 90, 93, 92, 94},\n  {99, 80, 75, 66, 50, 87, 33, 89, 99, 100}\n}; // 文末に ; を忘れないように\n2次元配列の要素を順番に出力するには，次のように2重ループを使う．\nint subject_num = 5;\nint student_num = 10;\n\nfor(int i = 0; i &lt; subject_num; i++){\n  printf(\"Subject no. %d\\n\", i);\n  for(int j = 0; j &lt; student_num; j++){\n    printf(\" %d\", score[i][j]);\n  }\n  printf(\"\\n\");\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#演習",
    "href": "week03.html#演習",
    "title": "3  C言語の復習 2",
    "section": "3.7 演習",
    "text": "3.7 演習\n以下の問題に取り組み，ソースコードをmanaba+Rにアップロードせよ．\n\n3.7.1 問題1\n行列の\\(A\\)をつぎのように定義する． \\[\n\\require{physics}\nA=\\mqty[1 & 1 & 3\\\\\n5 & 2 & 6\\\\\n-2 & -1 & -3]\n\\]\n\\(A^2\\)と\\(A^3\\)を計算して出力するプログラムnilpo.cを作成せよ．\n\n\n\n3.7.2 問題2\n銀行をひとつ選び，普通預金金利を調べよ．その金利に基づき，下記のとおり利息を付加する．1月1日に元本10万円を預け入れ，以後，30日おきに3万円を預け入れるとする3．1月1日を1日目とし，初めて100万円以上となるのは何日目かを出力するプログラムmillion.cを作成せよ．\n\n1日あたりの利息＝当日締めの預入残高×金利÷365 とする．ただし1円未満は切り捨てる\n半年複利とする\n\n上記で計算した利息を，半年に1回，2月15日（46日目）と8月15日（227日目）に元本に組み入れる\n\nうるう年は考慮せず，1年は必ず365日とする\n源泉徴収は考慮しない\n引き出しはしない\n\n出力例\n◯◯銀行に預けた場合 1234日 で100万円貯まります",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week03.html#footnotes",
    "href": "week03.html#footnotes",
    "title": "3  C言語の復習 2",
    "section": "",
    "text": "https://eeic-software1.github.io/2024/week1/↩︎\n1999年に制定された規格C99で配列のサイズを実行時に決定できるようになったが，それ以前は定数でなければならなかった．↩︎\n初回の預け入れは30日目の1月30日，2回目は60日目の3月1日↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>C言語の復習 2</span>"
    ]
  },
  {
    "objectID": "week04.html",
    "href": "week04.html",
    "title": "4  C言語の復習 3",
    "section": "",
    "text": "4.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#前回演習の解答",
    "href": "week04.html#前回演習の解答",
    "title": "4  C言語の復習 3",
    "section": "",
    "text": "受講上の注意【再掲】\nインデントを揃える\n配列の初期化（追記）",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#本日のメニュー",
    "href": "week04.html#本日のメニュー",
    "title": "4  C言語の復習 3",
    "section": "4.2 本日のメニュー",
    "text": "4.2 本日のメニュー\n\n繰り返しの中断 break, continue\n関数\n二分法\nニュートン法",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#繰り返しを中断する",
    "href": "week04.html#繰り返しを中断する",
    "title": "4  C言語の復習 3",
    "section": "4.3 繰り返しを中断する",
    "text": "4.3 繰り返しを中断する\nswitch文の説明で既に登場しているが，breakを使うと，直近の繰り返し文を中断して抜けることができる． do while文の例文で学習した入力された整数を返す繰り返し文は，次のようにbreakを用いて書き改めることができる．\nwhile (1) { // 条件式は常に真なので無限ループ\n  printf(\"整数を入力: \");\n  scanf(\"%d\", &a);\n  printf(\"--&gt; 入力された数: %d\\n\", a);\n  printf(\"終了する場合は 0 を入力: \");\n  scanf(\"%d\", &a);\n  if ( a == 0 ) {\n    break; // while文を抜ける\n  }\n};\nたとえば配列の要素を順番に確認して，目的のものが見つかった時点でループを終了する場合に使う． 以下は，テストの点数配列scoreをチェックして100点の人がいる場合は特定の文字列を出力するプログラムである．\nint student_num = 10;\nint score[] = {99, 80, 75, 66, 50, 87, 33, 89, 99, 100};\nfor (int i = 0; i &lt; student_num; i++){\n    if (score[i] == 100){\n        printf(\"100点満点の人が存在します\\n\");\n        break;\n    }\n}\n似たような働きをする文に，continueがある．これは，ループの以後の文をスキップして次のループに移動する． 以下は，50点未満の人を除いて得点を出力するプログラムである．\nfor (int i = 0; i &lt; student_num; i++){\n    if (score[i] &lt; 50){\n        continue; // 50点未満は以下の処理をスキップ\n    }\n    printf(\"番号%dの得点: %d\\n\", i, score[i]);\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#関数",
    "href": "week04.html#関数",
    "title": "4  C言語の復習 3",
    "section": "4.4 関数",
    "text": "4.4 関数\n繰り返し同じ処理をする場合は，関数としてまとめて使い回すと効率が良いし，プログラムが読みやすくなる． 関数とは，渡された値（引数）を処理して何らかの値を返す（戻り値）ものであり，main関数やその他の関数から呼び出されたタイミングで実行される． 関数は以下のような構造で記述する．\n戻り値のデータ型 関数名(引数のデータ型 引数名){文}\n3つの整数を受け取って，最大値を返す関数max3を書いてみよう．\nint max3(int a1, int a2, int a3)\n{\n    int max = a1;\n    if (a2 &gt; max) {\n        max = a2;\n    }\n    if (a3 &gt; max) {\n        max = a3;\n    }\n    return max;\n}\n1行目より，これはint型のデータを返す関数で，関数名はmax3，引数はint型のa1およびa2, a3であることがわかる． ブロック{}内には関数で行う処理の本体が書かれている． a1, a2, a3のうち最大のものがmaxに代入されるようになっており，最後にmaxをreturnで戻り値に設定している． 引数のa1, a2, a3は，関数本体内で宣言せずに使用していることに注意． これは，1行目の関数宣言時にデータ型と変数名が確定しているため． 一方，maxは関数内で新たに定義する変数なので{}内でint変数として宣言している．\n関数の呼び出しは，以下のように書く．\n#include &lt;stdio.h&gt;\n\nint max3(int a1, int a2, int a3) {\n  int max = a1;\n  if (a2 &gt; max) {\n    max = a2;\n  }\n  if (a3 &gt; max) {\n    max = a3;\n  }\n  return max;\n}\n\nint main(void)\n{\n  int a, b, c;\n  int max;\n  printf(\"整数を3つ入力: \");\n  scanf(\"%d%d%d\", &a, &b, &c);\n  max = max3(a, b, c);\n  printf(\"最大値は%d\\n\", max);\n  return 0;\n}\n\n\n\n\n\n\n条件演算子\n\n\n\n条件演算子を用いた式「式1 ? 式2 : 式3」は，式1が真ならば式2を評価した結果を，式2が偽ならば式3を評価した結果を返す．これを用いると2値a1, a2の大きい方をmaxに代入する文はmax = (a1 &gt; a2) ? a1 : a2;と書ける．3値の最大値も同様にコンパクトに書けるが多少わかりにくい: max = (a1 &gt; a2) ? ((a1 &gt; a3) ? a1 : a3) : ((a2 &gt; a3) ? a2 : a3);\n\n\n関数max3はmainより前に記述されているが，Cプログラム実行時に最初に実行されるのはmain関数であるという決まりがあるので，まず，mainの1行目が実行される． 整数を3つ入力した後，main関数の5行目でmax3が呼び出される． ここで，main関数内での引数の変数名a, b, cと，関数max3の引数名a1, a2, a3は一致していなくてもよい（一致していてもよい）． 関数max3の呼び出し時に，\na1 = a;\na2 = b;\na3 = c;\nという代入が行われると理解しよう．当然，関数max3内でa1の値が書き換えられたとしても，max3を呼び出した元の関数のaは影響を受けない．このように関数の引数は呼び出し元とは別の変数であり，値が代入されることを値渡しという．\nmax3の戻り値は，main関数内で宣言されたmaxという変数に代入される． ここで，main関数における変数maxと，max3関数内で宣言された変数maxは別物であることに注意． 変数は宣言されたブロック内に限り有効である．このような，変数の有効範囲をスコープと呼ぶ．\nどのブロック内でもない場所で宣言された変数は，ファイル内全体で有効である． 同じ名前の変数が複数有効な場合，よりそのブロックに近い変数を指す．\n#include &lt;stdio.h&gt;\nint x = 1; // ファイル全体で有効な変数\nint main(void){\n  int x = 2; // mainブロック内のみで有効な変数\n}\n上のプログラムでは，main関数内では4行目で初期化されたx = 2が有効となる．\n関数には，戻り値が不要なものや引数が不要なものがある．その場合は，データ型のところにvoidと書く． 以下は，特定の文字列を出力する処理を関数として独立させたものである．\nvoid put_mytext(void){\n  printf(\"これは関数内の処理です\\n\");\n}\n\nint main (void)\n{\n  int num;\n  printf(\"何回書きますか？: \");\n  scanf(\"%d\", &num);\n  for (int i = 0; i &lt; num; i++){\n    put_mytext();\n  }\n  return 0;\n}\nmain関数の5行目で関数put_mytextが呼び出されているが，引数として何も渡していないので()となっている． また，戻り値も無いのでput_mytextにはreturn文が無い．",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#方程式の数値解法",
    "href": "week04.html#方程式の数値解法",
    "title": "4  C言語の復習 3",
    "section": "4.5 方程式の数値解法",
    "text": "4.5 方程式の数値解法\n方程式\\(f(x) = 0\\), \\(x \\in [\\underline{x}, \\bar{x}]\\)を数値的に解く方法を考えよう．ここで，「数値的に」とは，\\(f(x)=0\\)を式変形して\\(x = \\alpha\\)として\\(\\alpha\\)を求める方法ではなく，\\(x\\)に具体的な数字を代入して計算することによって解\\(\\alpha\\)を求めることを意味する．\n\n\n\n\n\nたとえば\\([\\underline{x}, \\bar{x}] = [-1, 1]\\)として，上図のような関数\\(f(x)\\)がプロットできる場合は，\\(x = -1, 0, 1\\)付近が解であることがわかるが，その厳密な値はグラフからはわからない．また，\\(f(x)\\)が複雑でグラフを描いても解が読み取れない，そもそもプロットできない場合を想定するとよい．\n\n4.5.1 二分法\n探索範囲を2分割して絞り込む方法である． アルゴリズムへの入力として，解を挟む閉区間\\([a, b]\\)と，解の許容誤差\\(\\epsilon\\)を与えておく． \\(a\\)と\\(b\\)の中点を新たに\\(c\\)として，\\(f(c)\\)の正負によって探索範囲を\\([a, c]\\)か\\([c, b]\\)に絞る．探索範囲の幅が\\(\\epsilon\\)より小さくなった時点で探索を終了する．\n\n\n\n\n\n\nTip\n\n\n\n探索範囲を\\([a, b]\\)の内点に限定してよい理由は，中間値の定理より: \\(f(x)\\)が閉区間\\([a, b]\\)上で連続であり，\\(f(a)\\neq f(b)\\)ならば，\\(f(a)\\)と\\(f(b)\\)の間の任意の値\\(\\xi\\)に対して\\(f(c) = \\xi\\)なる\\(c\\in[a, b]\\)が存在する． ここでは\\(\\xi = 0\\)と考えればよい．\n\n\n\n初期入力: \\(f(a)\\)と\\(f(b)\\)が異符号であるような\\(a, b \\in [\\underline{x}, \\bar{x}]\\)，正数\\(\\epsilon\\)\n手順1: \\(c := (a + b)/2\\)とする．もし\\(f(c) = 0\\)ならば\\(c\\)を解として終了． もし\\(f(a)\\)と\\(f(c)\\)が異符号ならば\\(b \\leftarrow c\\)とする．もし\\(f(b)\\)と\\(f(c)\\)が異符号ならば\\(a \\leftarrow c\\)とする．\n手順2: \\(|b-a| &lt; \\epsilon\\)ならば\\(a, b\\)（またはその中点）を解として終了．そうでなければ手順1へ．\n\n以下は，\\(f(x) = x^2 -2 = 0\\)の解を，\\(a=0\\), \\(b = 2\\)を初期探索範囲として求めるプログラムである． ただし，二分法のアルゴリズム部分は実装していない（後の演習問題とする）．\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;  // 絶対値を求める関数 fabs を使用するため必要\n\n// 解きたい方程式 f(x) = x^2 - 2 = 0\ndouble f(double x) {\n  return x * x - 2;\n}\n\ndouble bisection_search(double a, double b, double eps) {\n  double c;\n  // 二分法の探索アルゴリズム\n  return c;\n}\n\nint main(void) {\n  double a = 0.0, b = 2.0, eps = 0.01;\n  if (f(a) * f(b) &gt; 0) {\n    printf(\"この範囲に解はありません\\n\");\n    return 0;\n  }\n  if (f(a) == 0 || f(b) == 0) {\n    if (f(a) == 0) {\n      b = a;\n    } else {\n      a = b;\n    }\n  } else {\n    a = bisection_search(a, b, eps);\n  }\n\n  printf(\"解はx = %lf\\n\", a);\n  return 0;\n}\n\n\n\n\n\n\n指数の数学的表記\n\n\n\n\\(0.0001 = 10^{-4}\\)のように0が長く続く数値は1e-4のように表記できる．1E-4, 1.0e-4でも可．同様に\\(10000\\)は1e4, 1E4, 1.0e+4のように表すことができる．いずれもdouble型となり，そのままではint型には代入できない．\n\n\n1回の反復で探索範囲\\([a,b]\\)が半分になるから，探索範囲の長さが\\(\\epsilon\\)より小さくなる反復回数を\\(N\\)とすると， \\[\n\\require{physics}\n\\frac{b-a}{2^N} &lt; \\epsilon\n\\Leftrightarrow N &gt; \\log_2\\qty(\\frac{|b-a|}{\\epsilon})\n\\] である．\n\n\n4.5.2 ニュートン法\n\n\n\n\n\n方程式\\(f(x) = 0\\)の解を求めるために，\\(f'(x)\\)が計算可能な場合を考えよう． ここで「\\(f'(x)\\)が計算可能」とは，\\(x\\)を具体的にひとつ決めれば対応する微分係数\\(f'(x)\\)を計算できるという意味である． 微分が計算できるなら，赤線のグラフを1次関数として近似できる．1次方程式の解は簡単に計算できるので，その解を近似解として採用すればよいのでは？ これをニュートン法と呼ぶ．\n初期解\\(x_0\\)を適当に定義域上に定め（上図では\\(x_0=1.2\\)），その点における勾配\\(f'(x_0)\\)を計算すれば，接線が求まる（上図の青線）． 接線が\\(x\\)軸と交わる点を新たな解の候補\\(x_1\\)とする（上図では\\(x_1 = 1.04096\\)）． これを繰り返せば，点列\\(x_n\\)は\\(f(x)=0\\)の解に近づくと期待できる．\n\n\n\n\n\n点\\(x_n\\)における接線の方程式は \\[\ny = f'(x_n)(x-x_n) + f(x_n)\n\\] であるから，この1次式が\\(x\\)軸と交わる点\\(x_{n+1}\\)は，\\(y=0\\)を\\(x\\)について解いて， \\[\nx_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}\n\\] となる．\n初期解\\(x_0\\)が解\\(\\alpha\\)に十分近いときにはニュートン法によって\\(x_n\\)は\\(\\alpha\\)に2次収束する． つまり，\\(x_n\\)が\\(\\alpha\\)に十分近いときには，ある\\(c&gt;0\\)を用いて \\[\n|x_{n+1} - \\alpha| \\approx c |x_n - \\alpha|^2\n\\] となる．\n探索の終了条件は，\\(f(x_n)\\)が0に十分近くなった場合や，解の候補がほとんど動かなくなった場合，つまり\\(x_{n+1}-x_n\\)が十分小さくなった場合とする: \\[\n|f(x_n)| &lt; \\epsilon \\quad\\text{or}\\quad |x_{n+1}-x_n| &lt; \\delta.\n\\]\n解の更新部分を除く実装例は以下の通り．\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\ndouble f(double x) {\n  return x * x - 2;\n}\ndouble dfdx(double x) {\n  return 2 * x;\n}\ndouble newton_search(double x, double eps, double dlt) {\n  double xnext;\n  // ニュートン法の探索アルゴリズム\n  return xnext;\n}\n\nint main(void) {\n  double x0 = 2.0, eps = 0.01, dlt = 0.01;\n  printf(\"解はx = %lf\\n\", newton_search(x0, eps, dlt));\n  return 0;\n}\n\n\n\n\n\n\nニュートン法の問題点\n\n\n\n初期解を解の十分近くに取る必要性に加え，\\(f'(x_n)\\)の逆数を解の更新に用いる点は，ニュートン法を適用するうえでしばしば障害となる．\\(f'(x_n)=0\\)となる場合に計算不能となるのはすぐわかる． 独立変数\\(x\\)が多次元の場合は，\\(f(x)\\)のヤコビ行列の逆行列を計算することに相当し，どの\\(x_n\\)に対してもこの逆行列の存在を保証することはハードルが高い．また，逆行列計算の計算量の多さも問題となる． そこで，\\(f'(x_n)\\)を近似的に計算するニュートン法の改良法が数多く提案されている． \n\n\n\n\n\n\n\n\n反復アルゴリズム\n\n\n\nニュートン法のように，解の候補\\(x_n\\)を\\(f(x_n)\\)や\\(f'(x_n)\\)の値を用いて更新するアルゴリズムは非常に広範囲で使われる． 一般的な形式で書き表すと， \\[\nx_{n+1} = x_n + \\alpha_n \\Delta x_n\n\\] の様に書け，\\(\\Delta x_n\\)は解を更新する方向を，\\(\\alpha_n\\)はどの程度解を動かすかを表している． 初見の数値解法アルゴリズムであっても，上式のように解釈すると意味がわかりやすい．",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week04.html#演習",
    "href": "week04.html#演習",
    "title": "4  C言語の復習 3",
    "section": "4.6 演習",
    "text": "4.6 演習\n\n4.6.1 問題1\nつぎのプログラムを実行し，出力される値を理由とともに説明せよ．ファイル名をscope.txtとする．\n#include &lt;stdio.h&gt;\n\nint x = 1;\n\nvoid print_x(void) {\n  int x = 10;\n  printf(\"%d\\n\", x);\n}\n\nint main(void) {\n  printf(\"%d\\n\", x);\n  int x = 100;\n  print_x();\n  for (int i = 0; i &lt; 3; i++) {\n    int x = 1000 + i;\n    printf(\"%d\\n\", x);\n    x++;\n  }\n  return 0;\n}\n\n\n\n4.6.2 問題2\n二分法の探索プログラムを完成させ，\\(\\cos(x / 2) = 0\\)の解を\\(x\\in[0, 6]\\)の間で求めよ．ファイル名はbisection.cとする．\n\n\n\n\n\n\n絶対値関数\n\n\n\n絶対値を求めるには，math.hをincludeしてfabs関数を使う．この関数はdouble型を引数として，その絶対値をdobule型で返す．\ndouble fabs(double)\nmath.hで定義されている関数一覧はこのページなどを参照．\n\n\n\n\n\n\n\n\n数学関数を使う場合のコンパイルエラー\n\n\n\nmath.hで宣言されている数学関数を使用すると，コンパイル時にエラーとなる場合がある．その場合は，lmオプションを付ける．\ngcc bisection.c -lm\n\n\n\n\n4.6.3 問題3\nニュートン法の探索プログラムを完成させ，\\(\\cos(x / 2) = 0\\)の解を\\(x\\in[0, 6]\\)の間で求めよ．ファイル名はnewton.cとする．",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>C言語の復習 3</span>"
    ]
  },
  {
    "objectID": "week05.html",
    "href": "week05.html",
    "title": "5  C言語の復習 4",
    "section": "",
    "text": "5.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#本日のメニュー",
    "href": "week05.html#本日のメニュー",
    "title": "5  C言語の復習 4",
    "section": "5.2 本日のメニュー",
    "text": "5.2 本日のメニュー\n\nマクロ\n文字，文字列",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#include指令",
    "href": "week05.html#include指令",
    "title": "5  C言語の復習 4",
    "section": "5.3 include指令",
    "text": "5.3 include指令\nコンパイラがソースコードを機械語に変換する前に，プリプロセッサがソースコードを編集する． このときの動作について説明する．\n#include &lt;ファイル名&gt;があるとき，その場所にファイル名で指定したファイルの中身が挿入される． 既存のライブラリ（のヘッダファイル）など，システム上のファイルを指定する場合はファイル名を&lt;と&gt;で囲う． 自作のファイルを読み込む場合はファイルパスを\"で囲う．",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#define指令オブジェクトマクロ",
    "href": "week05.html#define指令オブジェクトマクロ",
    "title": "5  C言語の復習 4",
    "section": "5.4 define指令（オブジェクトマクロ）",
    "text": "5.4 define指令（オブジェクトマクロ）\n#define a bと書くと，これ以降のaはbに置換される（ただし，\"で囲われた中身（文字列リテラル），変数名の一部は置換されない）． これをオブジェクトマクロと呼ぶ． プログラム中で使用する定数（プログラム実行中に書き換えることのない値）に名前をつけて可読性を上げたり，定数を変更する際の手間を省いたりするのに役立つ． たとえば，学生数分の配列を使う場合，下記のように書くことができる．\n#define STUDENT_NUM 30\nint main(void){\n    int score[STUDENT_NUM]; //コンパイルの前に int score[30] に置き換えられる\n    // ...\n    for(int i = 0; i &lt; STUDENT_NUM; i++) \n    // ...\n}\nオブジェクトの名前は，変数と区別するために大文字アルファベットで記述することが多い．\n#define PI 3.14159",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#define指令関数形式マクロ",
    "href": "week05.html#define指令関数形式マクロ",
    "title": "5  C言語の復習 4",
    "section": "5.5 define指令（関数形式マクロ）",
    "text": "5.5 define指令（関数形式マクロ）\nマクロを使って関数のようなものを定義できる． たとえば，2乗するマクロは以下の通り．\n#define SQR(x) ((x) * (x))\nint main(void){\n    int a = SQR(2); // a = ((2) * (2)) に置換され a = 4 となる\n}\n関数形式（int sqr(int x){ return x*x; }）と比較すると，型を限定しない関数（ぽいもの）を定義できるという利点がある． 例えば，上のSQR()は，\nint a = 2;\nprintf(\"%d\\n\", SQR(a));  // int型の変数を2乗\ndouble b = 2.2;\nprintf(\"%lf\\n\", SQR(b)); // double型の変数を2乗\nのように使うことができる．\n同様に2変数関数も作ることができる．\n#define MAX2(x,y) (x &gt; y ? x : y)\nここで，定義部分は条件演算子と呼ばれ，(条件式 ? 条件式が真の場合の値 : 条件式が偽の場合の値)という書式である．\nマクロには利点がある一方で，意図しない動作をする恐れがある点に注意が必要である． 例えばSQR(a++)は((a++) * (a++))に置換されることから，単にaの2乗を計算してからaをインクリメントするのではなく，インクリメントが2回行われる． もう一つの例として，\n#define NIBAI(x) (x * 2)\nint main(void){\n    printf(\"%d\\n\", NIBAI(3+4)); // 3+4 * 2 と展開される\n}\nとすると，NIBAI(3+4)は3+4 * 2と展開される． よって，おそらく想定していた\\(3+4 = 7\\)の2倍である\\(14\\)とは異なり，値は\\(3+8=11\\)となる．",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#ifdef指令",
    "href": "week05.html#ifdef指令",
    "title": "5  C言語の復習 4",
    "section": "5.6 ifdef指令",
    "text": "5.6 ifdef指令\nもうひとつ#を使う指令として，ifdefを紹介する． これを使うと，特定の名前のマクロが定義済みか否かによってプログラムの実行を分岐させることができる．\n#define マクロ名 値\n// ...\n#ifdef マクロ名\n  「マクロ名」が定義済みの場合にのみ，この部分を実行\n#endif\nたとえば，デバッグ用にprintf文を仕込んだとき，それを実行するか否かをマクロの有無で切り替えることができる．\n#define IS_DEBUG_MODE // デバッグモードでないときはコメントアウト\nint main(void){\n    #ifdef IS_DEBUG_MODE\n        printf(\"デバッグ用メッセージ\");\n    #endif\n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#文字",
    "href": "week05.html#文字",
    "title": "5  C言語の復習 4",
    "section": "5.7 文字",
    "text": "5.7 文字\n文字1字を表すにはchar型の変数を使う．1文字を表現するにはその文字を単引用符（'）で囲う． printfでchar型の文字を出力するには%cで書式指定する．\nchar moji = 'a'; // 文字「a」を変数mojiに代入\nprintf(\"%c\\n\", moji); // a を出力\ncharは1バイト分の整数（\\(0\\)–\\(255\\)または\\(-128\\)–\\(127\\)）を表現可能な型である． つまり，文字は，文字に対応する整数値で変数に保存される．\nchar moji = 'a';\nprintf(\"%d\\n\", moji); // 文字「a」に対応する数字 97 を出力\nこの整数値はASCII（アスキー）コードと呼ばれる．その一部を別表に示す．\n\n\n\n\n\n\nマルチバイト文字\n\n\n\nここでは文字として半角英数と記号(!\"#$%&'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~)を考える． 日本語の文字は1バイトでは表現できず，1文字を2バイト以上で表現する． 文字と数字の対応は文字コードに依存する．\n\n\n逆に，文字に対応する整数値を指定すれば，文字を表現することができる．\nchar moji = 97; // 整数値97を代入\nprintf(\"%c\\n\", moji); // 書式を%cで指定すると対応する文字「a」を出力\nASCIIコードを確認するとわかるが，連続するアルファベットは連続する数値が割り当てられている． また，Aとaは異なる文字なので，対応する数字も異なる．",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#文字列の基本",
    "href": "week05.html#文字列の基本",
    "title": "5  C言語の復習 4",
    "section": "5.8 文字列の基本",
    "text": "5.8 文字列の基本\n文字列は，文字の配列で表現する．つまりchar型の配列である． 文字を二重引用符（\"）で囲うと文字列を表す． このように，ソースコード上の\"で囲われた文字列の表現のことを文字列リテラルと呼ぶ．\nchar str[4] = \"abc\"; // 配列strを文字列リテラルで初期化\nprintfで書式指定を%sとすると，与えられた配列の文字列を出力する．\nprintf(\"%s\\n\", str); // 文字列に対応する書式指定は %s\nここで，配列strのサイズが4であることに注意する． これは，文字列は末尾に終端を意味する不可視の記号（NULL文字）を含むため． NULL文字は'\\0'と表現する．\nつまり，文字列の初期化\nchar str[4] = \"abc\";\nを文字に分解して書き表すと\nchar str[4] = {'a', 'b', 'c', '\\0'};\nとなり，両者の意味するところは同一である．\n\n\n\n\n\n\n文字列の末尾にはNULL文字が必要\n\n\n\n末尾にNULL文字が無い文字列はC言語の仕様に適さない．\nchar str[] = {'a', 'b', 'c'};\nprintf(\"%s\\n\", str);\nとすると，abcに続いて変な文字が出力される．",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#配列としての文字列",
    "href": "week05.html#配列としての文字列",
    "title": "5  C言語の復習 4",
    "section": "5.9 配列としての文字列",
    "text": "5.9 配列としての文字列\n文字列は配列であるから，普通の配列と同様に要素ごとに参照や代入が可能である．\nchar str[] = \"abc\"; // 配列を宣言と同時に初期化する場合はサイズを省略できる\n\n// 文字列として出力\nprintf(\"%s\", str); // abc\nprintf(\"\\n\");\n\n// 1要素ずつ文字として出力\nfor(int i = 0; i &lt; 4; i++){\n    printf(\"%c, \", str[i]); // a, b, c\n}\nprintf(\"\\n\");\n\n// 1要素ずつ数値として出力\nfor(int i = 0; i &lt; 4; i++){\n    printf(\"%d, \", str[i]); // 97, 98, 99\n}\nprintf(\"\\n\");\n通常の配列と同様，初期化以外で一括代入はできない．\nchar str[4];\nstr = \"abc\"; // エラー\n文字列の途中にNULL文字がある場合，最初のNULL文字までが文字列となる． たとえば\"abc\\0def\"という文字列リテラルで初期化した配列を文字列として認識した結果はabcである．\nchar str[] = \"abc\\0def\";\nprintf(\"%s\\n\", str); // abc\n\n\n\n\n\n\nNote\n\n\n\n文字列を初期化するときに，サイズ数より大きい文字列リテラルを代入するとNULL文字が入り切らずに切り取られて不正な文字列になるので注意．\nchar str[4] = \"abcd\"; // dの後のNULL文字が入りきらない\nprintf(\"%s\\n\", str);  // 意図しない出力\n逆に配列のサイズが初期化文字列より大きい場合は，残りの配列要素が0，つまりNULL文字で埋められるので，問題は生じない．\nchar str[10] = \"abcd\"; // 5番目以降は 0 = '\\0' で初期化\nprintf(\"%s\\n\", str);   // abcd",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#文字列の組",
    "href": "week05.html#文字列の組",
    "title": "5  C言語の復習 4",
    "section": "5.10 文字列の組",
    "text": "5.10 文字列の組\n複数の文字列はchar型の2次元配列で扱うことができる．\nchar name[][11] = {\"Alice\", \"Bob\", \"Charlie\"}; // 長さ11(= 10字+NULL文字)の文字の組を格納する2次元配列\nこの2次元配列の要素は下記のようである．\nname[0][0] = 'A', name[0][1] = 'l', name[0][2] = 'i',  name[0][3] = 'c', name[0][4] = 'e', name[0][5] = '\\0', ..., name[0][10] = '\\0',\nname[1][0] = 'B', name[1][1] = 'o', ...,\nname[2][0] = 'C', name[2][1] = 'h', ..., name[2][10] = '\\0'\n2次元配列の文字列を順に出力するプログラム（の一部）は以下の通り．\nchar name[][11] = {\"Alice\", \"Bob\", \"Charlie\"};\nfor(int i = 0; i&lt; 3; i++){\n    printf(\"%s\\n\", name[i]); // [i]が必要なことに注意\n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#文字列の読み込み",
    "href": "week05.html#文字列の読み込み",
    "title": "5  C言語の復習 4",
    "section": "5.11 文字列の読み込み",
    "text": "5.11 文字列の読み込み\nscanf関数でユーザーの入力を文字列として読み込むことができる．\n#include &lt;stdio.h&gt;\n#define MAX_CHAR 10\nint main(void){\n    char str[MAX_CHAR+1];\n    printf(\"文字列を入力してください:\");\n    scanf(\"%s\", str); // %s = 文字列として解釈, &をつけないstr\n    printf(\"%s と入力しましたね\\n\", str);\n    return 0;\n}\nこのとき，scanfに渡すstrに&が不要である点に注意． これは，配列名は配列先頭のアドレスを表すためであり，（配列ではない）変数にアドレス演算子&をつけたものと同種の情報を渡していることになる．\n\n\n\n\n\n\nscanfはスペースを区切り文字として扱う\n\n\n\nscanfはスペースで入力を区切るので，ユーザーがスペースを入力すると，その後の文字列はstrに格納されない． スペース（や改行）を含めて読み取るには，ファイル入出力に使うfgets関数を使うとよい．\nfgets(str, sizeof(str), stdin); // 読み込み先の配列，配列サイズ，読み込み元 (stdinは標準入力)\nprintf(\"%s と入力しましたね\\n\", str);",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#stringライブラリの便利関数",
    "href": "week05.html#stringライブラリの便利関数",
    "title": "5  C言語の復習 4",
    "section": "5.12 stringライブラリの便利関数",
    "text": "5.12 stringライブラリの便利関数\nstring.hには文字列関係の便利な関数が定義されている． いくつか紹介する．\n\n5.12.1 文字列の長さ\n\nstrlen(文字列): NULL文字を除く文字列の長さを返す\nstrcpy(配列名, 文字列): 配列名に文字列をコピーする\nstrcat(配列名, 文字列): 配列名内の文字列末尾に文字列を結合する\nstrcmp(文字列1, 文字列2): 文字列1と2を辞書式に大小比較し，文字列1が文字列2より小さい場合に負の整数，等しい場合に0，文字列1が文字列2より大きい場合に正の整数を返す\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint main(void) {\n  // 文字列の長さ\n  char s1[] = \"abc\";\n  unsigned int len = strlen(s1); // 文字列の長さを返す(NULL文字を除く)\n  printf(\"%d\\n\", len);\n  printf(\"%lu\\n\", sizeof(s1)); // sizeof(配列名)で配列のバイト数を返す. unsigined longなので%lu\n\n  // 文字列のコピー\n  char s2[10];\n  strcpy(s2, s1);     // s2にs1をコピー\n  printf(\"%s\\n\", s2); // abc\n\n  // 文字列の結合\n  char s3[10] = \"xyz\";\n  strcat(s3, s1);     // s3の後にs1を連結 (s3は十分長くとっておく)\n  printf(\"%s\\n\", s3); // xyzabc\n\n  // 文字列の比較\n  char s4[10] = \"abcd\";\n  int cmp1 = strcmp(s1, s4);    // s1 &lt; s2, 負\n  int cmp2 = strcmp(s1, \"abc\"); // s1 == s2, 0\n  printf(\"%d, %d\\n\", cmp1, cmp2);\n  \n  return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#演習",
    "href": "week05.html#演習",
    "title": "5  C言語の復習 4",
    "section": "5.13 演習",
    "text": "5.13 演習\n\n5.13.1 問題1\nユーザーが入力した文字列のうち，大文字アルファベットを小文字に，小文字アルファベットを大文字に変換するプログラムを作成せよ． 入力する文字列の最大数をマクロで定義すること． 入力は改行とスペースを含まない1行としてよい． ファイル名をalphabet.cとする．\n\nテスト入力: ABCdef&lt;=&gt;uVwXyZ\nテスト出力: abcDEF&lt;=&gt;UvWxYz\n\n\n\n5.13.2 問題2\n0, '0', \\0, \"0\", \"\\0\"の違いを説明せよ． ファイル名をq2.txtとする．",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week05.html#asciiコード",
    "href": "week05.html#asciiコード",
    "title": "5  C言語の復習 4",
    "section": "5.14 ASCIIコード",
    "text": "5.14 ASCIIコード\n\n\n\n文字コード (10進数)\n文字コード (2進数)\n文字\n\n\n\n\n0\n0000 0000\n(NULL)\n\n\n…\n…\n制御文字\n\n\n10\n0000 1010\n\\n (LF)\n\n\n…\n…\n制御文字\n\n\n32\n0010 0000\n(space)\n\n\n…\n…\n数字と記号\n\n\n65\n0100 0001\nA\n\n\n66\n0100 0010\nB\n\n\n67\n0100 0011\nC\n\n\n68\n0100 0100\nD\n\n\n69\n0100 0101\nE\n\n\n70\n0100 0110\nF\n\n\n71\n0100 0111\nG\n\n\n72\n0100 1000\nH\n\n\n73\n0100 1001\nI\n\n\n74\n0100 1010\nJ\n\n\n75\n0100 1011\nK\n\n\n76\n0100 1100\nL\n\n\n77\n0100 1101\nM\n\n\n78\n0100 1110\nN\n\n\n79\n0100 1111\nO\n\n\n80\n0101 0000\nP\n\n\n81\n0101 0001\nQ\n\n\n82\n0101 0010\nR\n\n\n83\n0101 0011\nS\n\n\n84\n0101 0100\nT\n\n\n85\n0101 0101\nU\n\n\n86\n0101 0110\nV\n\n\n87\n0101 0111\nW\n\n\n88\n0101 1000\nX\n\n\n89\n0101 1001\nY\n\n\n90\n0101 1010\nZ\n\n\n91\n0101 1011\n[\n\n\n92\n0101 1100\n\\\n\n\n93\n0101 1101\n]\n\n\n94\n0101 1110\n^\n\n\n95\n0101 1111\n_\n\n\n\n\n\n\n文字コード (10進数)\n文字コード (2進数)\n文字\n\n\n\n\n96\n0110 0000\n`\n\n\n97\n0110 0001\na\n\n\n98\n0110 0010\nb\n\n\n99\n0110 0011\nc\n\n\n100\n0110 0100\nd\n\n\n101\n0110 0101\ne\n\n\n102\n0110 0110\nf\n\n\n103\n0110 0111\ng\n\n\n104\n0110 1000\nh\n\n\n105\n0110 1001\ni\n\n\n106\n0110 1010\nj\n\n\n107\n0110 1011\nk\n\n\n108\n0110 1100\nl\n\n\n109\n0110 1101\nm\n\n\n110\n0110 1110\nn\n\n\n111\n0110 1111\no\n\n\n112\n0111 0000\np\n\n\n113\n0111 0001\nq\n\n\n114\n0111 0010\nr\n\n\n115\n0111 0011\ns\n\n\n116\n0111 0100\nt\n\n\n117\n0111 0101\nu\n\n\n118\n0111 0110\nv\n\n\n119\n0111 0111\nw\n\n\n120\n0111 1000\nx\n\n\n121\n0111 1001\ny\n\n\n122\n0111 1010\nz\n\n\n123\n0111 1011\n{\n\n\n124\n0111 1100\n|\n\n\n125\n0111 1101\n}\n\n\n126\n0111 1110\n~\n\n\n127\n0111 1111\nDEL",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C言語の復習 4</span>"
    ]
  },
  {
    "objectID": "week06.html",
    "href": "week06.html",
    "title": "6  C言語の復習 5",
    "section": "",
    "text": "6.1 おしらせ",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#おしらせ",
    "href": "week06.html#おしらせ",
    "title": "6  C言語の復習 5",
    "section": "",
    "text": "次週の授業について",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#本日のメニュー",
    "href": "week06.html#本日のメニュー",
    "title": "6  C言語の復習 5",
    "section": "6.2 本日のメニュー",
    "text": "6.2 本日のメニュー\n\nポインタ",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#ポインタの基本",
    "href": "week06.html#ポインタの基本",
    "title": "6  C言語の復習 5",
    "section": "6.3 ポインタの基本",
    "text": "6.3 ポインタの基本\nポインタとは，他の変数のメモリアドレスを格納する変数である． ポインタ変数ともいう．ポインタのデータサイズは，64ビットマシンなら64ビット（8バイト）である．\nポインタを宣言するには，データ型 *ポインタ名と書く． 例えば，int型のポインタは以下のように宣言する．\nint a = 10;\nint *p; // int変数へのポインタを宣言\np = &a; // 変数aのアドレスをpに格納\n3行目で，&は変数のアドレスを抽出する演算子なので，pにはaのアドレスが格納される．データを確認してみよう．printfでアドレスを出力する書式指定は%pである．\nprintf(\"%p\\n\", &a); // 0x16b386c88 (変数aのアドレス)\nprintf(\"%p\\n\", p);  // 0x16b386c88 (9桁しかないのは上の桁が0で省略されているため)\n2行目で，pの前には&がついていないことに注意．\nポインタに*をつけると，ポインタが指している変数（つまり，ポインタ変数に格納されているアドレスの変数）と同じ様に扱うことができる．*を間接演算子と呼ぶ．\nint a, b;\nint *p;  // int型へのポインタを宣言\na = 10;\np = &a;  // pにaのアドレスを格納\nb = *p;  // b = a;と同じ\n*p = 20; // a = 20と同じ\nprintf(\"%d\\n\", a);   // 20\nprintf(\"%d\\n\", *p);  // 20\n\n\n\n\n\n\n*をつけてポイント先の変数にアクセス\n\n\n\nこのときの*は，ポインタ変数宣言時の*とは全く別物である． 変数宣言時の\nint *p;\nは，意味的には\nint* p;\nつまり，int型データのアドレスを格納するint*型変数を宣言していると考えるとよい． 実際，int型変数は4バイト，ポインタ変数は8バイト1の変数で別物である．\n\n\n\n\n\n\n\n\nTip\n\n\n\nポインタ変数pをint* p;と宣言することも可能だが，複数個のポインタ変数をまとめて宣言する場合に直観に反する動作をするので，書き方としてはint *p;を推奨する．\nint* p1, p2, p3; // int *p1, p2, p3; と解釈される\nは，p1はポインタ，p2とp3はint型変数となる．\n\n\n\n\n\n\n\n\nTip\n\n\n\n通常の変数に対して*を使うことはできない．\nint a = 10;\n*a; // コンパイル時にエラー",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#関数の引数にポインタを使う",
    "href": "week06.html#関数の引数にポインタを使う",
    "title": "6  C言語の復習 5",
    "section": "6.4 関数の引数にポインタを使う",
    "text": "6.4 関数の引数にポインタを使う\n関数がreturnで返すことができるデータは1つだけであるが，ポインタを使うと2つ以上の値を得ることができる．\nつぎの例は，2つの変数a, bを受け取って2種類の計算a+bとa-bを行う関数sum_diffを定義している．\n#include &lt;stdio.h&gt;\nvoid sum_diff(int a, int b, int *add, int *diff) {\n  *add = a + b;  // ポインタaddの指すアドレスに値を書き込む\n  *diff = a - b; // ポインタdiffの指すアドレスに値を書き込む\n}\n\nint main(void) {\n  int ad, df; // 戻り値を格納するint型変数\n  sum_diff(10, 100, &ad, &df); // 戻り値用の *アドレス* を関数に渡す\n  printf(\"a-b: %d, a-b: %d\\n\", ad, df);\n  return 0;\n}\n関数の引数int *add, int *diffは計算結果の格納用で，int型のポインタとして受け取っている． 呼び出し元のmain関数では，戻り値の書き込み先のアドレス&ad, &dfを渡している（9行目）．関数sum_diff内では，*演算子を使ってアドレスで参照している先，つまりmainで宣言された変数にアクセスして計算結果を書き込んでいる．\nここで，関数の引数をポインタとせず，通常のint変数で渡すと，エラーにはならないが意図した動作は実現できない． これは，ポインタではない通常の変数を関数に渡すときには，関数内の変数に値がコピーされ，呼び出し元とは別の領域にデータが格納されるためである．これを値渡しという． これに対して，呼び出し元で用意したデータ格納先のアドレスを渡すと，関数内から呼び出し元の変数にアクセスすることができる．これを参照渡しと呼ぶ．\n値渡しと参照渡しの動作の違いを確認するため，渡された2つの数字を入れ替える関数の実装例を見てみよう．\n#include &lt;stdio.h&gt;\nvoid swap1(int a, int b) {// aとbを入れ替える（値渡し）\n  int tmp = a;\n  a = b;\n  b = tmp;\n}\n\nvoid swap2(int *a, int *b) {// aとbを入れ替える（参照渡し）\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint main(void) {\n  int a = 1;\n  int b = 10;\n  swap1(a, b);  // 値渡し\n  printf(\"swap 1: a = %d, b = %d\\n\", a, b); // 入れ替わらない\n\n  a = 1;\n  b = 10;\n  swap2(&a, &b); // 参照渡し\n  printf(\"swap 2: a = %d, b = %d\\n\", a, b); // 入れ替わる\n\n  return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#ポインタと配列",
    "href": "week06.html#ポインタと配列",
    "title": "6  C言語の復習 5",
    "section": "6.5 ポインタと配列",
    "text": "6.5 ポインタと配列\n\n6.5.1 ポインタで配列を走査\n配列は，メモリ上に連番で格納領域を確保するので，連続したアドレスが並ぶことになる．\nint a[3] = {0, 1, 2};\nint *p = &a[0];\n上の例では，ポインタpに配列の先頭a[0]のアドレスが格納される．\nここでpの値を1だけ増加させる．すると，pの値はint型データ1つ分のアドレス（つまり4バイト分）が加算され，a[1]のアドレスと一致する．\np++;                // pをインクリメント\nprintf(\"%d\\n\", *p); // 1 (=a[1])\n同様に，aがdouble型の配列でpがdouble型へのポインタであれば，pに1を加えるとdouble型データ1つ分のアドレス（つまり8バイト分）が加算される．\n#include &lt;stdio.h&gt;\nint main(void) {\n  double a[] = {0.0, 1.0, 2.0};\n  double *p, *q;\n\n  p = &a[0];\n  q = p + 1;\n  printf(\"%lf\\n\", *q);      // 1.0 (=a[1])\n  printf(\"%p, %p\\n\", p, q); // 0x16cf4ec70, 0x16cf4ec78\n  return 0;\n}\n\n\n6.5.2 配列名とアドレス\n第05回で触れたが，配列名単独は，配列の先頭を表すアドレスを意味する．\nint a[] = {0, 1, 2};\nint *p;\np = a; // p = &a[0]と同じ\nまた，配列要素のアドレスは配列名 + インデックス番号と書くことができる． これは，配列名がその配列の先頭へのポインタであることを考えると納得できるであろう．\na;     // = &a[0]\na + 1; // = &a[1]\na + 2; // = &a[2]\nこれを利用して，配列aのi番目要素を*(a + i)のように参照することができる．\n*(a + 1) = 0; // a[1]に 0 を代入\nまとめると，配列aのインデックス1番目を参照する方法として，以下の3種類は同じ意味である．\nint a[] = {0, 1, 2};\nint *p = &a[1]; // a[1]へのポインタ\na[1];     // a[1]の値\n*p;       // a[1]の値\n*(a + 1); // a[1]の値\n\n\n6.5.3 配列を引数とする関数\n配列を引数とする関数は次のように定義する．\n// 配列とその長さを受け取って，すべての要素を出力する関数\nvoid print_array(int a[], int n){\n  for(int i = 0; i &lt; n; i++){\n    printf(\" %d\", a[i]);\n  }\n  printf(\"\\n\");\n}\nこれは，配列先頭へのポインタを渡す関数としても定義できる．\n// 上の関数の引数の表現をポインタに変えたもの\nvoid print_array(int *a, int n){\n  for(int i = 0; i &lt; n; i++){\n    printf(\" %d\", a[i]);\n  }\n  printf(\"\\n\");\n}\nここで，関数の中身（3–6行目）は全く同一であることに注意．つまり，ポインタpに対してp[i]との表記も可能であり，これは*(p + i)を表す．\n\n\n\n\n\n\nTip\n\n\n\n関数の引数を配列形式int a[]とするかポインタ形式int *aとするかは，読ませたい意図によって使い分けることが多いようである．つまり，配列としての意味を強調したいのか，ポインタとして読ませたいかに依る． いずれの場合でも，配列のサイズを超えてアクセスすることがないように，配列のサイズを併せて関数に渡す．\n\n\n配列名とポインタが全く同一のように扱えるか，というとそうではない． たとえば，配列aに別の配列のアドレスを代入することはできない．\nint a[] = {0, 1, 2}\nint *p = a;\nint b[] = {3, 4, 5};\np = b; // OK\na = b; // コンパイル時にエラー",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#演習",
    "href": "week06.html#演習",
    "title": "6  C言語の復習 5",
    "section": "6.6 演習",
    "text": "6.6 演習\n\n6.6.1 問題1\n要素数5のint型配列aを宣言し，中身を適当に定義せよ． 2種類の方法でaの要素を順番に出力するプログラムを作成せよ． ファイル名はq1.cとする．\n\na[i]のインデックスiをインクリメントするfor文\na[0]のアドレスを格納するポインタをインクリメントするfor文\n\n\n\n6.6.2 問題2\ndouble型配列の要素を逆順に並べ替えて返す関数invertを作成せよ．ただし，invertはポインタを引数とし，関数内でa[i]のように配列にインデックスでアクセスする書き方をしないものとする．\nvoid invert(double *a, int n){\n  // a[i]という書き方は使わない \n}\nファイル名はq2.cとする．",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week06.html#footnotes",
    "href": "week06.html#footnotes",
    "title": "6  C言語の復習 5",
    "section": "",
    "text": "64ビットマシンの場合．↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C言語の復習 5</span>"
    ]
  },
  {
    "objectID": "week07.html",
    "href": "week07.html",
    "title": "7  C言語の復習 6",
    "section": "",
    "text": "7.1 前回演習の解答",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#前回演習の解答",
    "href": "week07.html#前回演習の解答",
    "title": "7  C言語の復習 6",
    "section": "",
    "text": "ポインタ，ポインタと配列",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#本日のメニュー",
    "href": "week07.html#本日のメニュー",
    "title": "7  C言語の復習 6",
    "section": "7.2 本日のメニュー",
    "text": "7.2 本日のメニュー\n\n構造体\n共用体",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#構造体",
    "href": "week07.html#構造体",
    "title": "7  C言語の復習 6",
    "section": "7.3 構造体",
    "text": "7.3 構造体\n単一の数値や文字を保持するにはintやcharなど適当な型を設定した変数を用いて，一連のデータをまとめて扱うには，配列を使えばよかった． たとえば，あるクラスのテストの点数をまとめて管理するためにint型の配列を用いた． これに，テスト受験者の名前—つまり文字列データ—を紐づけて管理するにはどうすればよいか？\n構造体 (structure) を使うと，異なるデータ型をひとまとめにできる．構造体は，その内部に包含するデータの型を宣言し，あたかも新たなデータ型のように使うことができる． つぎの例は，ある人物に関するデータをまとめた構造体の宣言である．\nstruct person{\n  char name[128];  // 氏名\n  float height;    // 身長\n  float weight;    // 体重\n  int age;         // 年齢\n};\n行頭にstructを付けると，構造体の宣言となる．personはその構造体の名前（構造体タグ (structure tag)）である． タグに続くブロック{}の中に，この構造体が含むデータ（メンバ (member)）のデータ型とその名前が定義されている．\n\n\n\n\n\n\nNote\n\n\n\n構造体宣言ブロックの末尾には;が必要である．関数の定義と異なることに注意．\n\n\nこれは構造体personという型の宣言であって，personという名前の変数が作られるわけではない． 実際にデータを格納するには，“person型”の変数を宣言して，値を代入する．\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; // 文字列をコピーする関数strcpyのために必要\nstruct person {\n  char name[128];  // 名前\n  float height;    // 身長\n  float weight;    // 体重\n  int age;         // 年齢\n};\n\nint main(void) {\n  struct person ohtani;\n  strcpy(ohtani.name, \"Shohei Ohtani\");\n  ohtani.height = 1.93;\n  ohtani.weight = 95.3;\n  ohtani.age = 30;\n  printf(\"%s (%d)\\n\", ohtani.name, ohtani.age);\n  printf(\"H: %4.3f m, W: %4.2f kg\\n\", ohtani.height, ohtani.weight);\n  return 0;\n}\n上のプログラムでは，3–8行目で構造体personを宣言している．この段階ではメモリ上にデータ領域は確保されていない．11行目で，“person型”の変数ohtaniが宣言され，ここでメモリ領域が確保される．大きさはchar[128] = 128バイト，float ✕ 2 = 8バイト，int ✕ 1 = 4バイトの計140バイトである 1． 12–15行目で，ohtaniのメンバに値が代入されており，そのデータは16, 17行目で参照されている．\n.は構造体のメンバにアクセスする演算子である．\n\n\n\n\n\n\n.演算子\n\n\n\n構造体変数struc_nameのメンバmem_nameにアクセスするには，struc_name.mem_nameと書く．\n\n\n\n\n\n\n\n\nTip\n\n\n\nメンバnameは（ポインタ変数ではなく）配列として宣言されているため，\nohtani.name = &\"Shohei Ohtani\"; // エラー\nのように文字列リテラルのアドレスを代入して書き換えることはできない．また，既に宣言済みであって初期化ではないので\nohtani.name = \"Shohei Ohtani\"; // エラー\nもコンパイルエラーとなる．\n\n\n宣言と同時に初期化する場合には，配列の初期化と同様に{}の中に,区切りでメンバの値を指定する．上のプログラムのmain関数部分を以下のように書き換えた．\nint main(void) {\n  struct person ohtani = {\"Shohei Ohtani\", 1.93, 95.3, 30}; // 初期化\n  printf(\"%s (%d)\\n\", ohtani.name, ohtani.age);\n  printf(\"H: %4.3f m, W: %4.2f kg\\n\", ohtani.height, ohtani.weight);\n  return 0;\n}\n\n\n\n\n\n\nTip\n\n\n\n配列の初期化と同様に，{}でメンバの一部のみ初期化した場合は，残りのメンバは0で初期化される．",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#構造体へのポインタ",
    "href": "week07.html#構造体へのポインタ",
    "title": "7  C言語の復習 6",
    "section": "7.4 構造体へのポインタ",
    "text": "7.4 構造体へのポインタ\n構造体は複数のデータ種類を一つの変数にまとめることができるので，関数の引数をコンパクトに，わかりやすく表現することができる．たとえば，人物に関するデータ処理を行う関数は，名前，身長，体重などのデータを個別に渡すよりも，人物データをひとつの変数にまとめた方がわかりやすいし，保守性が高い．\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nstruct person {\n  char name[128];  // 氏名\n  float height;    // 身長\n  float weight;    // 体重\n  int age;         // 年齢\n};\n\nvoid printBMI(struct person p) { // BMIを出力する関数\n  printf(\"%s's BMI: %f\\n\", p.name, p.weight / p.height / p.height);\n}\n\nint main(void) {\n  struct person ohtani = {\"Shohei Ohtani\", 1.93, 95.3, 30};\n  printBMI(ohtani);\n  return 0;\n}\n関数で構造体のデータを書き換えるには，構造体へのポインタを関数に渡して（参照渡し），呼び出し元における構造体を関数内で書き換える必要がある．\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nstruct person {\n  char name[128];  // 氏名\n  float height;    // 身長\n  float weight;    // 体重\n  int age;         // 年齢\n  double bmi;      // BMI\n};\n\nvoid calcBMI(struct person *p) { // BMIを書き込んで返す関数\n  double b = (*p).weight / (*p).height / (*p).height;\n  (*p).bmi = b;\n}\n\nint main(void) {\n  struct person ohtani = {\"Shohei Ohtani\", 1.93, 95.3, 30};\n  calcBMI(&ohtani);\n  printf(\"BMI: %lf\\n\", ohtani.bmi);\n}\nここで，(*p).bmiはp-&gt;bmiと書くこともできる．-&gt;をアロー演算子という． この表現を使うと，上の関数calcBMIはつぎのようにも書ける．\nvoid calcBMI(struct person *p) { // BMIを書き込んで返す関数\n  double b = p-&gt;weight / p-&gt;height / p-&gt;height;\n  p-&gt;bmi = b;\n}\n\n\n\n\n\n\nアロー演算子\n\n\n\n構造体へのポインタpのメンバmemを参照するには，(*p).memだけでなく\np-&gt;mem\nと書くこともできる．",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#構造体の受け渡し",
    "href": "week07.html#構造体の受け渡し",
    "title": "7  C言語の復習 6",
    "section": "7.5 構造体の受け渡し",
    "text": "7.5 構造体の受け渡し\n配列と異なり，構造体変数に別のオブジェクトを代入することができる．\nstruct person p1, ohtani = {\"Shohei Ohtani\", 1.93, 95.3, 30};\np1 = ohtani;  // 正常\nしたがって，構造体を返す関数を定義して，戻り値を呼び出し元で宣言した構造体変数に代入することもできる．つぎの例の関数createPersonは，必要な情報を受け取って，それらの情報を一つの構造体に加工して呼び出し元に返す関数である．\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nstruct person {\n  char name[128];  // 氏名\n  float height;    // 身長\n  float weight;    // 体重\n  int age;         // 年齢\n  float bmi;       // BMI\n};\n\nstruct person createPerson(char name[], float h, float w, int a) {\n  struct person p = {\"\", h, w, a};  // 構造体に詰めて返す\n  strcpy(p.name, name);\n  p.bmi = w / h / h;\n  return p;\n}\n\nint main(void) {\n  struct person p;\n  p = createPerson(\"Shohei Ohtani\", 1.93, 95.3, 30);\n}\n構造体の配列も，通常のデータ型の配列と同様に定義できる．\nstruct person player[10];\nplayer[0] = createPerson(\"Shohei Ohtani\", 1.93, 95.3, 30);\nplayer[1] = createPerson(\"Aaron James Judge\", 2.01, 127.9, 33);\n// 後略",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#共用体",
    "href": "week07.html#共用体",
    "title": "7  C言語の復習 6",
    "section": "7.6 共用体",
    "text": "7.6 共用体\n構造体は型の異なるデータをまとめて管理できるが，メンバを増やすと使用するメモリ領域が大きくなる．複数の型のデータを格納するが，同時に保持するのはひとつのメンバだけという場合には，共用体 (union) として宣言することでメモリ領域を節約できる．\nたとえば，文字，整数，浮動小数点数のいずれかが入るデータ型keywordを定義したいとする．char, int, doubleの3種類をメンバとして持つ構造体は，\nstruct keyword{\n  char c;   // 1バイト\n  int i;    // 4バイト\n  double d; // 8バイト\n};\nとなり13バイト以上（データの切れ目を調整するパディングによって16バイト）が必要である．\nしかし，メンバのうち複数を同時に保持することが無いのであれば，一番大きなdoubleに合わせてメモリ領域を確保しておき（つまり8バイト分），実際には格納しているデータ型に応じて読み出す領域を決めてあげればメモリを節約できる．これは共用体で実現できる．\nunion ukeyword{\n  char c;   // 1バイト\n  int i;    // 4バイト\n  double d; // 8バイト\n}; // 最大のdoubleに合わせて8バイト（宣言時に）確保される\n共用体オブジェクトの参照には構造体と同じく.演算子を使う．",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#演習",
    "href": "week07.html#演習",
    "title": "7  C言語の復習 6",
    "section": "7.7 演習",
    "text": "7.7 演習\n\n7.7.1 問題1\n書籍の情報を保持する構造体を定義して，手元にある3冊の本の情報を構造体配列に保存せよ． 書籍1冊の情報には，以下を含むこと．\n\n書名\n著者名\n価格\nISBN\n発行年\n\nこの構造体を用いて，以下の動作を実現せよ．\n\n本1冊の情報を出力する関数を作成し，それを用いて3冊全ての情報を出力する\n発行年が古い順に配列を並び替える関数を作成し，並び替えを実行する\n再び3冊全ての情報を出力し，ソートが完了していることを確認する\n\nプログラム名はq1.cとする．\n\n\n7.7.2 問題2\n以下の情報を含む構造体personを定義せよ．\n\n名前\n\n文字列\n\n性別\n\n‘M’または’F’\n\n父親\n\nperson型へのポインタ\n\n母親\n\nperson型へのポインタ\n\n\nサザエさん一家の人物情報を構造体に格納せよ．Fuguta Taraoから出発し，母系の系譜を順に出力せよ．ファイル名はq2.cとする．\n父母が「不明」の場合は，NULLに設定せよ．NULLは何も指さないことを意味する特殊なポインタである．使い方は以下の通り：\npsn[0].father = NULL;\n\n\n\n名前\n性別\n父\n母\n\n\n\n\nIsono Namihei\nM\n不明\n不明\n\n\nIsono Fune\nF\n不明\n不明\n\n\nFuguta Masuo\nM\n不明\n不明\n\n\nFuguta Sazae\nF\n-&gt; Isono Namihei\n-&gt; Isono Fune\n\n\nIsono Katsuo\nM\n-&gt; Isono Namihei\n-&gt; Isono Fune\n\n\nIsono Wakame\nF\n-&gt; Isono Namihei\n-&gt; Isono Fune\n\n\nFuguta Tarao\nM\n-&gt; Fuguta Masuo\n-&gt; Fuguta Sazae",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  },
  {
    "objectID": "week07.html#footnotes",
    "href": "week07.html#footnotes",
    "title": "7  C言語の復習 6",
    "section": "",
    "text": "確かめるにはprintf(\"%lu\\n\", sizeof(struct person))としてみよう．メンバの型と順番によってはバイト数の切れ目を調整するパディングが発生し，単純にメンバのデータサイズの和より大きくなることがある．↩︎",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>C言語の復習 6</span>"
    ]
  }
]